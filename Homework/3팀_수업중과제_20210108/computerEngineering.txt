컴퓨터 공학(영어: Computer engineering)은 컴퓨터 하드웨어 및 소프트웨어를 개발하는 데 필요한 전기공학 및 컴퓨터 과학의 여러 가지 분야를 통합하는 학문 분과이다. 현대 정보화 사회에서 컴퓨터의 하드웨어와 소프트웨어를 연구, 컴퓨터 시스템과 컴퓨터 관련 기술을 개발하여 익히고 이를 각 분야에 응용함을 목적으로 한다.

하드웨어 부분에서 전자기학 이론 분야와 마이크로프로세서 분야, 전자 회로 분야로 나뉘고, 소프트웨어 부분에서 컴퓨터 과학 이론 분야와 컴퓨터 프로그래밍 분야, 컴퓨터 시스템 분야 등으로 나뉜다. 컴퓨터 과학과 전자공학이 연계되는 학문으로, 컴퓨터를 비롯한 전자제품이나 로봇 공학 등, 하드웨어와 소프트웨어 지식이 둘 다 필요한 분야들이 대표적이다.

기초 분야: 전자기학, 회로, 이산수학, 자료 구조, 오토마타, 알고리즘 등 컴퓨터 기술을 발달시키기 위한 기반이 되는 논리를 다루는 부분.
프로그래밍 분야: 컴퓨터 기술의 핵심을 이루는 분야로 C, C++, Java 등 여러 가지 프로그래밍 언어로 컴퓨터에게 명령하여 작동시키는 기술을 연구.
시스템 분야: CPU를 비롯한 컴퓨터의 하드웨어 구조와 컴퓨터 시스템을 구성하는 운영 체제, 네트워크 등을 취급.

컴퓨터공학
최근 수정 시각: 2021-01-08 07:25:17

분류 컴퓨터 공학
나무위키+유도  이 학문을 가르치는 학과에 대한 내용은 컴퓨터공학과 문서를 참조하십시오.
과학의 범위
형식과학의 일반적 분류
수학
컴퓨터과학
통계학
논리학
암호학
1. 명칭
1.1. 공학?
2. 분류
2.1. 이론
2.2. 실용 코딩, 프로그래밍 실무
2.3. 전자공학, 시스템 아키텍처
2.4. 전산 통계학, 데이터 과학
2.5. 계산 인지과학(인지컴퓨팅), 계산 신경과학
2.6. 전산 언어학, 프로그래밍 언어학
2.7. 시스템 프로그래밍, 운영체제
2.8. 소프트웨어공학, 개발방법론, 시스템공학
2.9. 멀티미디어 (컴퓨터그래픽, 영상, 게임, 사운드 등)
2.10. 통신공학, 네트워크
2.11. 보안공학
2.12. 전산/계산 암호학
3. 다른 학문과의 관계
3.1. 전기공학 / 전자공학
3.2. 수학 / 통계학 / 논리학 / 암호학
1. 명칭[편집]
電算科學 / Computer Science

참고로 다른 한자문화권 국가에서는 '컴퓨터과학'을 '정보학'으로 번역하지만 대한민국에선 전산학으로 번역하여 전산학/전산과학으로 부르기도 한다.
1.1. 공학?[편집]
범주
컴퓨팅
분야
컴퓨터과학[1]
컴퓨터공학
설명
수학과 가까움
소프트웨어 위주
전자공학과 가까움
하드웨어 위주
컴퓨터과학과 전자공학을 이어주는 분야
영문
Computer Science
Computer Engineering
번역명
전산학/전산과학
전산공학
한자
電算科學
電算工學
배우는 학과
(한국기준)
컴퓨터과학과, 전산학과
일부학과를 제외한 대부분의 컴퓨터공학과
보통 전자공학과의 세부전공이다.
정보통신공학과는 컴퓨터공학을 메인으로 한다.
배우는 학과
(미국기준)
컴퓨터과학과(Computer Science)
컴퓨터공학과(Computer Engineering)또는
전자공학과(Electronic Engineering)

한국에선 컴퓨터과학과 컴퓨터공학을 크게 구분하여 말하지 않는다. 하지만 북미•유럽권에서는 컴퓨터를 다루는 것을 의미하는 컴퓨팅(Computing)이라는 영역 안에 크게 컴퓨터과학(Computer Science)과 컴퓨터공학(Computer Engineering)이라는 갈래로 나뉘어 구분한다.

컴퓨터과학은 응용수학과 전산학이론을 중점적으로 다루는 분야에 가깝다. 반면 컴퓨터공학은 전자공학과 컴퓨터 하드웨어를 중점적으로 다루는 분야다. 통상 북미권에서는 전자공학과 컴퓨터공학을 합쳐 EECE로, 컴퓨터과학을 CS로 하여 많이 분류한다.

하지만 대한민국의 컴퓨터공학과에서 컴퓨터공학(Computer Engineering)보다는 실질적으로는 컴퓨터과학(Computer Science) 위주로 배우는 경우가 대부분이다.[2] 이는 기존의 컴퓨터과학과가 컴퓨터공(工)학과라고 이름을 바꿈으로써 공학계열 등록금을 받을 수 있기에(...) 2000년대 들어서 많이 변경했기 때문이다.[3] 이에 따라 소속 단과대학도 정보대학, 공과대학. 자연과학대학 등 학교별로 다르게 속해있다. 또한 이학사를 받는지 공학사를 받는지도 다르지만, 보통은 공학사를 받는다.
2. 분류[편집]
컴퓨터과학은 천문학이 망원경에 관한 학문이 아니듯, 기계에 관한 것이 아니다. 수학과 컴퓨터과학 사이에는 본질적인 통일성이 있다.
― 에츠허르 다익스트라

흔히 컴퓨터과학과를 프로그래밍을 배우는 학과라고 생각하지만, 그것은 마치 경영학과가 주판을 배우는 학과라거나, 의류의상학과를 바느질을 배우는 학과, 기계공학을 용접하는 곳이라고 생각하는 것과 같다. 컴퓨터과학과는 컴퓨터과학이라는 독립적인 학문을 배우는 학과라는 것을 명심하자. 컴퓨터를 물리적 기기로 보고 연구하는 학문이 아니라, Compute + r, 즉 계산기계라는 "개념"과, 그 구조에 대한 학문이다. 우리가 흔히 쓰는 데스크탑, 스마트폰 등은 그러한 개념들을 구체화한 일부일 뿐이다.

이를 일컫어 Hal Abelson은 컴퓨터과학(Computer Science)이라는 이름이 이 분야를 소개하기에 나쁜 이름이라고 한 바 있다. 이 학과를 컴퓨터과학(Computer science)이라고 부르는 것은 마치 물리학을 입자가속기학과, 생물학을 현미경학과로 부르는 셈. 그래서 전산(電算) 과학이라고 하는 것이 그래도 포괄적인 이 분야에 대한 설명으로 적합한 느낌이다.
2.1. 이론[편집]
이론전산학, 수리전산학, 응용수학 등의 명칭을 사용한다. 컴퓨터의 수학적 기반에 대해 다룬다. 컴퓨터과학은 다른 공학 분야보다 수학을 압도적으로 많이 사용한다. 컴퓨터를 다루는 언어와 기법이 모두 수학이기 때문이다.
이산수학: 공대 학과 중 전산계열에서만 배우는 수학.
알고리즘: 알고리즘의 시간 복잡도및 공간 복잡도를 주로 다룬다. 시간 복잡도의 경우 처리해야 하는 데이터가 많아질수록 필연적으로 알고리즘의 실행이 끝나는 속도가 느려지는데, 늘어나는 처리 데이터에 비례해서 얼마나 알고리즘의 실행 속도가 느려지느냐가 관건이다. 예를 들어, n 만큼의 데이터를 처리해야 할때 O(n^{2})O(n 
2
 ) 복잡도를 가진다면, 처리해야 하는 데이터의 양에 제곱을 한 만큼 비례해서 알고리즘이 느려진다. 공간복잡도의 경우 처리해야하는 데이터에 비례해서 알고리즘이 얼마나 많은 양의 메모리를 필요로 하는가가 관건이다. 이를테면, 동적계획법을 활용한 배낭 문제에 대한 해의 경우, 시간 복잡도는 다항식적인데 공간복잡도는 기하급수적이다!
오토마타 이론: 기초적인 automaton과 결정가능성, 그리고 튜링머신에 대해 배운다.
정수론: 암호 분야에 사용 된다.
집합론
그래프 이론
조합론
이산 확률론
수리논리학: 분야를 가리지 않고 등장하기 때문에 중요하다. 일부 학자들은 비표준 논리학, 오토마타, 계산이론, 증명 이론까지 다룬다.
형 이론
해석학
미적분학
함수해석학과 측도론: 기계학습에 쓰인다.
대수학
선형대수학
범주론
기하학
이산/계산 기하학 : 컴퓨터를 이용해서 물체를 어떻게 표현 할 할지 연구하는 분야이다. 컴퓨터 그래픽에서 대표적으로 많이 사용하고 최근에는 컴퓨터 비전, 기계학습, 인공지능 분야에서도 사용된다.
이산 미분 기하학
미분방정식 : 컴퓨터 그래픽스에서 물체의 움직임에서 사용하기도 하고, 계산 과학 분야에서도 사용한다.
확률과 통계


위와 같이 수학 전반을 다루기 때문에 수학 전공자들의 복수전공에서 다른 공학 분야보다 용이하다. 실제로 이쪽은 교수부터 수학 전공자인 경우가 많다. 다만, 한국에서는 거의 죽은 분야에 가깝다. 한국의 경우, 교육열이 입시에 쏠려있어, 고교수학에 매우 강하며 실제 대학에서도 이런 경향이 이어져 고교 때 배우는 미적분을 많이 다루는 해석학과 같은 분야쪽에 쏠리는 경향이 강하다. 비표준 논리학은 수학에서 해석학과 거리가 가장 먼 분야로 볼 수 있으며, 덕분에 한국에서 이쪽 전공 교수 자체가 별로 없다. 다만 철학과까지 범위를 넓혀보면 그나마 숫자가 좀 늘어나긴 한다. 즉 철학과에도 수리 논리학은 물론이고, 비표준 논리학도 건드려본 논리학 전공 교수들이 있다. 참고로 논리학은 원래 철학의 한 분야지만, 국내 수학과 내에 논리학 전공 교수가 많지 않듯이, 국내 철학과에서도 논리학 전공 교수가 많진 않다. 당연히 컴퓨터 과학에서도 마찬가지. 국내는 이쪽 관련 인프라가 열악하므로 이쪽을 전공하고 싶다면 해외로 나가는 수밖에 없다. 하지만 최근 대학에서 이론 전산학을 연구하는 교수들이 조금씩 늘어가고 있다.[4]
2.2. 실용 코딩, 프로그래밍 실무[편집]
실무에서 쓰이는 테크닉들. Python, C, C++, Java가 가장 많이 사용되는데, 무엇을 먼저 가르칠지는 교수의 성향과 전공에 따라 달라진다. 전문대나 취업학원, 폴리텍의 경우 이런 과목이 특히 많다. 앞의 4대 주류 언어들은 대부분의 학교에서 1~2학년 과목으로 취급하고,[5] 2학년 이후 교육 과정에서 스크립트 언어[6][7], 함수형 언어[8], 논리형 언어[9] 등을 가르치는 것이 보통이다. 아예 일반적이지 않은 프로그래밍 언어 몇 개를 모아서 "고급 프로그래밍" 정도의 과목명으로 가르치는 강의를 개설하는 경우도 있다[10].
2.3. 전자공학, 시스템 아키텍처[편집]
논리회로와 CPU 구조, 마이크로프로세서, 컴퓨터 구조, 임베디드 등 컴퓨터가 어떻게 생겼고, 어떤 원리로 동작하는지 배운다.
2.4. 전산 통계학, 데이터 과학[편집]
자료구조, 파일구조, 데이터베이스, 데이터 마이닝 등 데이터의 효과적인 저장과 탐색, 처리법을 배운다. 학교에 따라서는 고급 통계학을 추가적으로 가르치는 곳도 있는데 대학원에 진학할 생각이 있다면 반드시 배워두자. 절대 손해 안 본다. 특히 인공지능[11]과 이것을 응용하는 분야(영상처리, 음성처리, 정보검색 등), 자연어처리, 네트워크 프로토콜 같은 분야를 염두에 두고 있다면 확률통계는 무조건 필수이므로 학부 때 미리 빠삭하게 해 놓으면 상당히 좋다. 이 분야는 해석학, 선형대수 등 기본적으로 수학 실력이 어느 정도 필요하고, 수학 실력이 부족하면 대학원을 안 가느니만 못한 사태가 발생할 수도 있다.
2.5. 계산 인지과학(인지컴퓨팅), 계산 신경과학[편집]
인공지능, 인공신경망, 기계학습을 다루는 분야.

학부 수준에서는 맛만 보는 수준 이상의 내용을 다루는 데는 한계가 있다. 그래도 Prolog나 자연어처리(NLP), 검색엔진(정보검색) 같은 것을 아주 약간이나마 접해볼 수 있다.
2.6. 전산 언어학, 프로그래밍 언어학[편집]
언어학, 수학, 전산학의 학제적 연구 분야 이다. 기본적으로 놈 촘스키의 생성문법적 관점에서 의미론과 통사론을 배우는 것이며, 여기서 파생되는 다양한 프로그래밍/컴퓨터 언어, 대수학(정확히는 환론과 군론, 카테고리 이론), 컴파일러의 구현법 등을 추가로 배우게 된다. 컴파일러 작성을 통한 언어 구현을 중시하며 그에 관련된 이론은 맛보기로 배우는 경우도 있는가 하면, 아예 관련 이론만 빠삭하게 들이파는 경우도 있다. 만약 PL 교수가 학생들에게 '프로그래밍 언어 분야' 를 소개하고자 한다면, 보통 수업 시간에 증명을 상당히 많이 다루게 된다. 반면, 교수가 학생들에게 그냥 다양한 언어들의 특성을 가르치게 된다면, 그런 느낌은 별로 들지 않는다. 만약 후자면 프로그래밍 경험이 많으면 잘 따라갈 수 있지만, 그렇지 않고 증명 느낌으로 과목을 가르치게 되면, 수학적인 논리가 부족한 학생들은 죽을 맛이 된다...
2.7. 시스템 프로그래밍, 운영체제[편집]
운영체제의 개념과 *NIX, Windows API/MFC 프로그래밍 등 시스템에 종속적인 프로그래밍을 배운다. 얼핏 보면 난해한 수학이 없다고 방심하면 안 되는 게, 운영체계라는게 오만가지 부속과 모듈들이 오만가지 방법으로 얽혀있어서 디버깅이 매우 힘들며, 따라서 관련 코딩 작업에 생각보다 아주 많은 시간을 소비하게 된다. 운영체제의 경우 이론만 배우는 경우가 많으나 대한민국 공대 중에서 PintOS[12]를 직접 코딩해보는 학교로 서울대, 카이스트, 포스텍, 서강대 등이 존재한다. 한양대와 홍익대에서도 원한다면 xv6와 GeekOS를 코딩 해 볼 수 있다. 숭실대에서도 PintOS를 코딩할 수 있는 과목이 있다. 오픈 소스 운영체제인 리눅스 커널 소스 코드를 직접 수정/컴파일/설치하여 돌려보는 학교도 있다.
2.8. 소프트웨어공학, 개발방법론, 시스템공학[편집]
요구공학, 분석, 설계, 구현, 테스트, 유지보수, 형상관리, 개발 방법론, 품질 관리, 재사용성 등 소프트웨어 개발에 있어서 체계적인 접근 방법에 대해 공부하게 된다.
2.9. 멀티미디어 (컴퓨터그래픽, 영상, 게임, 사운드 등)[편집]
MPEG, 영상 신호처리, 코덱, 미디어의 압축[13]과 전송, 음향 등 멀티미디어와 관련된 내용을 배운다. 게임 프로그래밍을 배우는 경우도 있다. 절대로 포토샵, MAYA 같은 툴 사용법을 배우는게 아니다! 의외로 빠삭한 양의 수학이 들어가기 때문에 얕잡아보면 후회하게 될 것이다.

DirectX, CUDA, OpenGL 등을 주로 사용한다. 숙제의 일환으로 간단한 게임을 만들게 될 수도 있다- 그 유명한 "머릿글자 B - 관악최속전설"도 그래픽 과목 숙제로부터 기원한다. 어느 정도의 미적분 실력과 선형대수학 실력만 있어도 수업에서 배우는 내용을 따라하고 숙제를 풀어내는 데에는 별 문제가 없겠지만, 보다 근본적으로 이해하려면 기하광학과 미분기하학에 대한 지식이 필요하다.
2.10. 통신공학, 네트워크[편집]
네트워크와 통신, 클라우드 컴퓨팅 등이 있다. OSI 계층에 따른 분류를 기준으로 각각의 구조를 배우기도 하며 네트워크 통신 프로그래밍을 지칭하는 경우도 있으며 그 두개의 짬뽕을 의미하기도 하는 역시 잘 하는 사람은 잘 하고 못 하는 사람은 희망이 없는 과목으로 보는 경우가 많은 분야.[14]
2.11. 보안공학[편집]
정보보안, 인터넷 보안, 네트워크 보안, 사이버안보 등의 이름으로 개설된다. 지금까지 배웠던 것들을 모두 싸그리 뭉쳐서 응용하는 성격이 강하며, 여기에 더해 사회공학적 기법도 대략적으로 가르치는 경우도 있다.
2.12. 전산/계산 암호학[편집]
정수론을 선행해야 한다. 수학과 언어학을 바탕으로 컴퓨터로 새로운 문법과 의미구조를 만들어야 한다. 이런 학문은 보통 다국적 IT기업, 군사기관, 경찰기관, 정보기관의 투자를 받아서 연구되는데, 대부분 일부 선진국에서만 제대로 연구되고, 국내에서 제대로 다루는 학교는 매우 적다.
3. 다른 학문과의 관계[편집]

공학과 과학에 모두 발을 걸친데다 생긴지 얼마 안된 학문이니만큼, 역사가 길지는 않다. 당장 전자, 기계, 화공을 가르치는 교수들은 각각 전공이 그쪽 분야인 데 비해, 컴퓨터공학을 가르치는 교수들 중에서 고령자들은 전자공학이나 수학과 출신인 경우도 많다. 애초에 컴퓨터공학이 세계적으로도 전자공학과 수학과의 접점에서 시작했기 때문이다.
3.1. 전기공학 / 전자공학[편집]
컴퓨터는 두가지로 구성되있다. 물리적하드웨어와 하드웨어설계등의 바탕이된 계산이론등을 다루는 컴퓨터과학으로 구성되있다. 하드웨어의 경우 물리학자들과 전기전자공학자들이 발전시켰고, 컴퓨터과학이론(오토마타,컴파일러...)등의 경우 수학자들과 컴퓨터과학자들이 발전시켰다. 현대에도 전자공학, 통신공학 등의 전자기학 기반 학문들과 연관성이 교류가 이루어지고 있다.
3.2. 수학 / 통계학 / 논리학 / 암호학[편집]
한편 컴퓨터과학은 수학자, 통계학자, 논리학자, 암호학자들에 의해 발전되었다. 먼저 수학자 앨런 튜링과 그 동료들에 의해 데이터 처리의 토대가 완성되었으며, 수리언어학 등을 기반으로 컴퓨터를 통제하기 위한 기초 문법들이 만들어졌다. 또 현대 통계학과 컴퓨터과학은 데이터과학이란 이름으로 학제간 연구가 이루어지고 있다.

[1] 일반적으로 한국에서 부르는 컴퓨터공학과이다.
[2] 물론 시립대 전전컴 처럼 정말 Computer Engineering에 초점이 맞춰진 학과도 있다. 실제로 컴퓨터과학은 정직하게 아예 별도의 학과로 편성되어 있다.
[3] 보통 대학교에서는 등록금이 문과 < 이과 < 공과 < 예체능 < 의과 순이다.
[4] 연세대학교 컴퓨터과학과의 한요섭, 안형찬 교수, 카이스트의 마틴 지글러, 정지원 교수 등이 있다.
[5] 서강대학교 처럼 오직 C만 집중적으로 깊게 가르치고 나머진 수박 겉핥기식으로 배우는 학교도 있다
[6] JavaScript, PHP 등
[7] 몇몇 학교는 반대로 이해하기 편한 스크립트 언어를 1학년 때 배우기도 한다.
[8] LISP, Haskell 등
[9] Prolog 등
[10] 보통 학교에 프로그래밍 언어를 연구하는 교수가 있으면 이런 과목들이 개설된다.
[11] 현재 인공지능은 통계적 기법이 대세다. 룰이나 논리 기반 추론은 이미 연구될 만큼 연구되었고 더 이상 주목할 만한 학문적 성과가 나오고 있지 않기 때문이다.
[12] 90년대에는 UC 버클리에서 만든 Nachos를 많이 사용했다. PintOS는 2004년에 스탠퍼드에서 Nachos를 개량하여 대체한 실험용 운영체제이다.
[13] JPEG라든지
[14] 그래도 이쪽 분야로의 진로를 계획하는 사람이 있다면 독학으로라도 공부해 두도록. 현업에 나가면 이쪽의 지식을 써먹을 분야가 많다. 소켓 프로그래밍을 할 필요가 없는 웹 개발자라 하더라도 이쪽 지식을 알고있는 사람과 모르는 사람간의 격차가 크다. 특히 규모가 작은 회사에서는 개발자가 서버 및 네트워크 환경까지 구축하는 경우가 흔한데 이 경우 네트워크에 대한 배경지식이 없으면 상당히 고생할 수 있다. 시간이 정말 없거나 하기가 싫어도 최소한 TCP와 HTTP프로토콜 정도는 공부는 해 두는게 좋다.

1. 개요
2. 최초의 프로그래머
3. 종류
3.1. 컴퓨터 과학 연구원
3.2. 보안 개발자
3.3. 보안 오퍼레이터
3.4. 소프트웨어 아키텍트(SA)
3.5. 게임 개발자
3.6. 웹 개발자
3.7. 모바일 개발자
3.8. 임베디드 시스템
3.9. 전산 정보 시스템
3.10. 융합형
3.10.1. 타 분야 컴퓨터 과학 연구원
3.10.2. 빅데이터 분석가
3.11. 코더
4. 조언
4.1. 첫 언어
4.1.1. 국내 취업에 필요한 C, C++, Java부터 시작해야 가장 유용하다는 쪽
4.1.2. 쉬운 언어부터 택한 뒤 이를 기반으로 자기가 필요한 언어로 나아가라는 쪽
4.2. 필요한 장비
4.2.1. 운영체제
4.2.2. 모니터
4.2.3. 키보드
4.3. 한 가지 언어만으로는 부족하다
4.4. 학위의 위상
4.4.1. 고학력이 요구되는 경우
4.4.2. 학력이 낮을 경우
4.5. 다른 분야의 지식
4.6. 필요한 능력
4.6.1. 꾸준한 공부
4.6.2. 영어
4.7. 연봉과 근무
5. 기타
6. 유사 용어
7. 관련 문서
1. 개요[편집]
프로그램 만드는 일을 하는, 혹은 그게 직업인 사람. 전 세계적으로 유명한 프로그래머로 빌게이츠가 있다.

이 나무위키도 프로그래머가 만들었다. 어떻게 짰는지 보려면 Ctrl+U를 눌러보자. (또는 F12도 된다.) 어지러울 수도 있으니 조심! 이것을 눌렀을 때 나오는 이상한 언어들이 전부다 코드다. 어우야...겁나 많네...[1][2]

쓸 만한 프로그래머들은 자신의 시간을 프로그램에 대해 생각하는 데에만 80% 이상을 쓰고, 그걸 직접 구현하는 데엔 20%도 안 쓴다 카더라. 그리고 프로그래머들은 자신의 능력을 이용해 간혹 기발한 일을 벌이기도 하는데[3], 그게 나쁜 쪽으로 발현된 것 중에 하나가 바로 랜섬웨어를 비롯한 컴퓨터 바이러스들이다.

서양에서는 '프로그래머들 중엔 비만이 많다'는 편견이 있다. 하루종일 컴퓨터 앞에 앉아서 간식을 처묵하는 이미지다. 실제로 프로그래머들은 대부분 의자에 앉아 있는 시간이 많으므로 대개 운동이 부족하다. 게임 개발자들은 돼지나 멸치 둘 중 하나라는 자조적인 평가도 가끔 들을 수 있다. 아주 가끔 좋은 피지컬을 가진 분들을 만날 수 있기는 하다. 다만 그 비율이 너무나 작을뿐..
2. 최초의 프로그래머[편집]
최초의 프로그래머로 인정받는 사람은 바로 러브레이스 백작부인 에이다 킹(1815 ~ 1852)이다. 생몰년도를 보자. 컴퓨터는커녕 증기 기관이 퍼져나가기 시작하던 시대의 사람이다. 그녀는 최초로 찰스 배비지의 해석기관의 컴퓨터 상의 구현을 알고리즘으로 설명한 사람이며, 폰 노이만 구조의 등장을 예견하였다. 참고로 유명한 영국 낭만주의 시인 조지 고든 바이런의 딸이다.

배비지의 해석기관은 당대의 기술로는 구현 불가능한 장치였다. 러브레이스는 실존하지 않는 컴퓨터에 대해 상상만으로 프로그램을 작성한 셈이다.
3. 종류[편집]
'프로그래머'라는 단어 하나로 간편하게 통칭하여 부르고 있긴 하지만, 프로그래머에도 여러 분야가 있다. 고급 언어와 툴을 다루는 프로그래머부터, 추가로 저급 언어까지 다루는 프로그래머까지 그 스펙트럼은 어마어마하게 넓다.(고급/저급은 언어의 난이도나 질을 의미하는 것이 아니라, 언어가 얼마나 기계에 가까운지를 나타낸다. 고급이 인간에 가깝다는 뜻이고, 저급이 기계에 가깝다는 뜻이다.) 또 소수의 코어파트 프로그래머들이 있는가 하면, 다수의 양산형 프로그래머인 코더가 있다.

컴퓨터 프로그래밍 기술에 능숙한 사람들은 유명세를 타기도 하지만, 이러한 관심을 받는 대상은 보통 소프트웨어 공학자 집단으로 국한된다. 그리고 종종 저명한 프로그래머들 중에는 "해커"라는 이름으로 불리는 사람들도 있다.

프로그래머라는 직종이 이런 넓은 스펙트럼을 가지고 있기 때문에 단순히 뭉뚱그려 부르기에는 상당히 무리가 있다. 비유를 하자면 트럭, 택시, 버스, 중장비기사를 전부 뭉뚱그려 '운전자'라고 표현하는 것과 같다.
3.1. 컴퓨터 과학 연구원[편집]
알고리즘을 개발하는 사람. 엄밀히 말하면 프로그래머는 아니다. 컴퓨터과학자가 새로운 알고리즘을 발표하면 타 분야의 개발자들이 자기 분야로 가지고 가서 적용한다. 대개 이쪽은 컴퓨터과학 중에서도 이론전산학, 혹은 수학과 중 수리논리학 쪽을 전공하고 박사학위를 가지고 있는 경우가 많다.

DSP, 선형대수, 암호학 같은 알고리즘들은 분야를 가리지 않고 널리 쓰이기 때문에, 논리적 엄밀성과 성능만이 최우선적 고려사항이고, 성능 좋은 수학 라이브러리 몇 가지를 개발해 놓으면 몇십 년이 지나더라도 별로 변하지 않는 편이다.
3.2. 보안 개발자[편집]
해킹 및 정보보안 관련 기술들을 다루는 프로그래머를 의미하며, 이를 위해서는 많은 기반 지식이 필요하다. 필요하면 서버 등의 플랫폼의 보안성 향상을 위해 툴을 준비하거나 서버 프로그래밍 자체를 튜닝하고 감시할 체제를 준비해야 하기 때문에 보통 고급 개발자이다. 업무에 비해 책임이 막대하며 특히 보안사고가 터지면 모든 책임을 뒤집어쓰는 직종이기 때문에 IT업계에서도 대우가(급여가 아닌) 상당히 좋지 못하다.

운영 체제, 네트워크(TCP/IP)에 대해 매우 심도깊은 이해가 필요하고 C언어를 매우 잘 다룰 줄 알아야 한다.[4] 최소한 한 종류 이상의 어셈블리어를 다룰 수 있어야 한다. 현대 암호학에 대해 개념 정도는 알고 있어야 하며(암호 알고리즘을 만들 줄 알아야 하는 건 아니다) 높은 수준의 리버스 엔지니어링 실력이 요구된다.
3.3. 보안 오퍼레이터[편집]
국내에서는 보안 관리자, 보안 시스템 유지보수 전문가 등으로 부른다. 하지만 영어권에서는 개발자가 아니라 Operator라고 분명히 구분한다. 국내에 이런 오퍼레이터 전문 육성 코스가 없어서 다들 프로그래밍을 하다가 이쪽으로 넘어오는데 전공 지식을 거의 활용할 수 없어서 기초부터 새로 배워야 하는 경우가 부지기수다. 오퍼레이터는 프로그래머의 하위 분류가 아니라 이웃 분류이다. 동등한 전문성을 갖추고 있는 반면 그 전문 영역이 별로 겹치지 않는다.

이들은 개발자와 달리, 운영 중인 시스템을 지속적으로 모니터링하다가 보안침해가 의심되면 신속하게 차단하고 피해 정도를 파악해 복구하는 일을 한다.
3.4. 소프트웨어 아키텍트(SA)[편집]
마이크로소프트의 정의에 따르면, 전략, 조직 역학, 프로세스, 커뮤니케이션, 리더십 등 관리능력과 엔지니어링에 대한 깊은 이해를 갖춘 개발 지휘자를 아키텍트라 부른다. 여길 참고하자

프로그래밍과 기획 능력이 둘 다 필요하다. 둘 중 하나라도 부족하면 정상적으로 업무를 진행하기 어렵다.
컴퓨터: 시니어 프로그래머 이상의 컴퓨터 구조에 대한 지식, 각 언어 특성에 대한 이해, 유지보수를 감안한 클래스 구조 설계 능력
기획: 요구사항 수집, 분석, 조직 관리 능력, 리스크 관리 능력 등
3.5. 게임 개발자[편집]
게임 프로그래머 문서 참고
비디오 게임 제작자 문서의 게임 프로그래머, 데이터베이스 관리자 항목 참고
3.6. 웹 개발자[편집]
웹 개발자는 HTTP 프로토콜, TCP 등 네트워크를 매개체로 사용하는 웹 서버, 웹 사이트와 관련된 소프트웨어 개발자, 소프트웨어 엔지니어를 말한다. 대다수의 웹개발자들은 웹 디자인, 정보설계, 사용자 인터페이스 설계, 프로젝트 관리, 웹 서버 및 데이터베이스 관리, 웹페이지 코딩 및 프로그래밍 관련 기술을 가지고 있다.
웹퍼블리셔(ui개발자) : HTML 중심이거나, 서버사이드가 감싸는 웹구조의 형태를 지향하는 업무 스타일의 직군으로서 웹퍼블리셔는 사용자에게 보여지는 인터페이스 영역을 작업하고, 개발자는 데이터의 비지니스 로직을 전반으로 담당한다. 웹퍼블리셔는 해외에서는 UI개발자로 불린다.

* 예상연봉 :
하위(25%) 2,634만원
평균(50%) 3,349만원
상위(25%) 3,970만원
프론트엔드 개발자 : 정적인 마크업을 제외하고 브라우저 위에서 동작하는 코드를 작성하는 개발자. 좀 더 자세히 말하면 프론트엔드 개발자는 백엔드 API에서 가져온 데이터의 출력, 입력을 통한 비지니스 로직 구성과 사용자와 대화하는 사용자 인터페이스 부분을 작업하는 개발자를 말한다. 유사한 직종으로 웹퍼블리셔가 있는데, 웹퍼블리셔는 html 중심이거나, 서버사이드가 감싸는 구조 형태의 웹을 지향하는 웹퍼블리셔와 개발자의 업무 스타일의 직군으로서 웹표준 반응형웹과 UI를 만드는 디자인 쪽에 가깝고 클라이언드 사이드 영역이기도 하지만, 프론트 엔드 개발자는 프론트엔드와 백엔드의 완전한 분리 구조를 지향하는 업무스타일의 직군으로서 (웹퍼블리셔와 같이 인터페이스의 디자인 관점도 있지만) 웹퍼블리셔와 달리 컴포넌트 아키텍쳐를 지향하며, 이벤트나 서버와 API 통신해서 로직을 어떻게 푸는 관점을 중시한다. 웹퍼블리셔와 프론트엔드 개발자의 차이점은 사용하는 언어와 어떤것에 특화되어 있는지를 보면 된다. 퍼블리셔는 HMTL, CSS 같은 마크업 언어와 약간의 JavaScript를 사용하여 디자인을 정적인 페이지로 표현하는것에 특화되어 있지만, 프론트엔드 개발자는 JavaScript 계열의 언어를 사용하여 서버간의 상호작용(Interaction)을 로직으로 풀어나가는 것에 집중한다. 웹브라우저 프로그램 위에서 동작하는 JavaScript를 사용하므로, 프론트엔드 개발자가 되고 싶다면 깊은 수준으로 이해하고 있어야 한다. 최근 나오는 프론트엔드 프레임워크도 거의 대다수가 JavaScript에서 파생되어 있다.
백엔드 개발자 : 백엔드란, 요청을 받는 서버 프로그램을 지칭하며, 이 프로그램을 작성하는 개발자를 백엔드 개발자라고 한다. 백엔드 개발자도 기존 개발자와 스펙이 조금 다르고, 백단에서 모든 작업을 완료해야 하며, 데이터베이스 분석과 API서버를 개발한다. 프론트엔드에서 전달된 데이터의 포맷이나 데이터베이스 입출력 및 다양한 비즈니스 프로세스를 프로그래밍 코드로 구현하는 역할을 한다. 데이터베이스, 웹서버, 네트워킹 등 웹 서버의 인프라에 대한 이해가 필요하다. 일반적으로 클라이언트에서 들어온 요청을 효율적으로 DB에 쿼리하여, 응답할 수 있는 코드를 작성하는것이 주 업무이며 널리 쓰이는 언어로는 Java, PHP, C# 등이 있는데 요즘은 JavaScript도 Node.js를 통해 사용이 가능하게 되었다. 보통 이런 언어를 다루고 SQL을 통해 하나 이상의 RDB를 다룰 수 있어야 업무가 가능하다. 고급 개발자로 갈수록 DB관리 및 성능튜닝, 서버에 대한 직접적인 관리 능력이 요구되며 ERP나 금융계열 회사로 취업할 경우 비즈니스 로직을 이해하는 것이 상당히 중요해진다. 한국의 학원에서 제일 많이 양산되는 것이 스프링, 전자정부 프레임워크를 속성으로 배운 서버 개발자이다.
풀스택 개발자 : 프론트엔드와 백엔드를 둘 다 프로그래밍 할 수 있는 능력자로써, 일반적으로 스타트업 같은 소기업에서 많이 필요로 한다. Node.js의 등장으로 JavaScript를 사용한 서버 프로그램 작성이 가능해지고, 또 JavaScript를 활용한 React, Angular 같은 프론트엔드 프레임워크도 급속도로 발전하면서 JavaScript 언어 하나로 백엔드, 프론트엔드 모두 프로그래밍이 가능하게 되면서[5] JavaScript를 할 수 있는 인력을 채용하여 한 사람이 두 영역 모두 담당하는 경우가 많아지게 되었다. 일은 두 배 지만 월급은 한 사람분
3.7. 모바일 개발자[편집]
스마트폰 애플리케이션을 개발하는 사람이다. 2010년 이후 지금까지 가장 많이 사용되는 안드로이드, iOS 두 가지 모바일 운영체제의 소프트웨어를 개발한다. 사람, 조직에 따라 한 종류만 개발하기도 하고 둘 다 개발하기도 한다.
안드로이드 APP 개발 : 안드로이드는 Java를 기반으로 하는 언어이기 때문에 Java에 대한 지식이 필요하며 2017년 부터 구글에서 표준 언어로 채택하고 있는 Kotlin서또한 학습해야 한다. 단, 유니티 엔진으로 개발하는 대다수의 인디 모바일 게임 개발자의 경우는 C#에 대한 지식이 필요하다. 물론 Java도 쓸 수 있지만 대부분의 유니티 개발자들은 C#을 애용하기 때문. 안드로이드 앱은 이클립스로 개발이 가능했다가, 구글의 정책으로 안드로이드 스튜디오에서만 개발이 가능하도록 변경됐다.
iOS APP 개발 : iOS는 macOS의 언어와 동일하게 Objective-C와 Swift에 대한 지식이 필요하다. 두 가지 언어의 컴파일러로는 대부분 macOS의 Xcode를 사용하며 이는 macOS에서 앱스토어를 들어가면 설치할 수 있다. 단, 유니티 엔진으로 개발하는 대다수의 인디 모바일 게임 개발자의 경우는 안드로이드와 마찬가지 이유로 C#에 대한 지식이 필요하다.
하이브리드 APP 개발 (안드로이드와 iOS 모두 호환 가능): HTML5로의 발전, CSS3의 발전 등을 통해 제약이 많던 이전 웹 언어들과 달리 현재는 다양한 애니메이션과 기능이 추가되었으므로 이를 활용해 OS의 제약 없이 개발할 수 있게 되었다. 그러나 한 종류 언어 위주로 개발하는 데 비해 출력이 매끄럽지 않아서 대다수 스마트폰 앱으로 먹고사는 벤처기업은 하이브리드 앱을 개발하지 않고 네이티브 언어를 채택한다. 스마트폰 앱이 주력사업이 아닌 대기업들의 경우엔 개발 비용을 줄이고자 하이브리드 APP을 많이 채택한다. 오픈 소스로 Sencha 등을 활용하는 편이다. 이쪽 분야에서는 Xamarin이나 Flutter 등의 프레임워크가 유명하다.
3.8. 임베디드 시스템[편집]
3.9. 전산 정보 시스템[편집]
SI(시스템 구축) 문서 참고.
SM(시스템 유지보수) 문서 참고.
ERP
3.10. 융합형[편집]
프로그래밍에 특정 분야의 전문 지식이 요구될 경우 프로그래머는 프로그래밍을 해내기 어려운데, 이런 영역에서는 해당 분야의 전문가가 자신의 지식을 활용해서 프로그래밍을 하기도 한다. 의사가 직접 의료 프로그램을 통계화, 수치화한다든가, 국과수 직원이 치아 감별을 통한 개인 식별을 위한 프로그래밍을 한다든가, 이과 대학 교수가 모델링-시뮬레이션 툴을 만든다든가, 병리학자가 혈액 샘플에서 적혈구, 백혈구 세포를 분류하고 정상 수치와 대조하여 질병 진단에 활용하는 등의 경우가 이에 속한다.

이들은 프로그램을 구현할 수만 있으면 프로그램 최적화 능력은 코더 수준이라도 상관없다. 어차피 전문가들은 해당 분야에 대한 지식이 없어서 이런 프로그램을 만들기 어렵기 때문이다. 프로그램에 불필요한 부분이 덕지덕지 붙어 있든 개발에 시간이 오래 걸리든 상관없다. 프로그램이 성공하면 프로그래머에게 맡겨서 개선시키면 그만이다.
3.10.1. 타 분야 컴퓨터 과학 연구원[편집]
수학, 물리학, 공학 등의 대학원생이나 교수들이 많이 분포해 있다. 국내외를 막론하고 '프로그래머, 개발자, 기술자'라고 불리기보다는 '과학자, 연구원, 교수' 등으로 불린다.

특정 상황에서 더욱 효율적인 알고리즘을 만들어내고 이를 수학적, 논리적으로 증명하는 게 주 목적. 실제로 프로그래밍은 최소한도로만 수행하거나 아예 수행하지 않는다. 대부분 한 종류 이상의 프로그래밍 언어에 능숙하지만 결과물을 프로그램으로 발표하는 게 아니라 논문으로 주로 발표하는 것도 큰 차이다. 프로그래밍 언어도 정말 순수하게 도구로서 다루는 것이지 그것이 생계 수단인 건 아니다.
3.10.2. 빅데이터 분석가[편집]
빅데이터를 분석하고 해석한다. 통계학과 컴퓨터공학을 둘 다 전공한 융합형 프로그래머에 속한다. 높은 수준의 수학 능력이 필요한 반면 프로그래밍 실력은 그렇게까지 요구되지 않는다. 사용하는 도구도 통계와 수치연산에 특화된 R이나 Python(NumPy)을 더 선호하고 데이터베이스에 대한 지식도 필요하다.
3.11. 코더[편집]
과거 코더란 프로그램 코드를 볼 수 있고, 이에 따른 전반적인 테스트를 할 수 있는 사람을 의미하는 용어였다. 오늘날은 단순히 코딩만 할 줄 알 뿐, 자기 프로그램을 개발할 능력은 없는 어설픈 프로그래머를 비하하는 의미로 변형되어 쓰이고 있다.

과거에는 '의사 코드'와 코드의 차이가 컸기 때문에 코더도 충분한 월급을 받으며 일할 수 있었다. 가령, 60년대에는 단순히 천공카드에 자료를 펀치하는 사람도 고급 인력이었다. 하지만 프로그래밍 언어가 많이 발전해서 현대의 프로그래밍 언어는 의사 코드에 매우 가까워졌다. 따라서 프로그래머가 의사 코드를 만들어서 코더한테 던져주는 저수준 작업은 요즘에 거의 사라졌다.

반면, 코더의 수는 늘어나고 있다. 기술의 발전으로 프로그래머용 툴도 입문 난이도가 내려갔다. 이 덕분에 프로그래밍의 진입 장벽은 학원에서 배우거나 IT쪽 고등학교에서 컴퓨터과를 졸업해서 일자리를 구할 수 있을 정도로 낮다.[6]

의사 코드(Pseudo code)가 주어졌을 때 그걸 실제로 동작하는 코드로 구현하는 것에 그치는 사람, 소스 코드를 복사해서 문맥에 맞게 수정하는 것밖에 할 줄 모르는 사람은 코더[7]다. 이것도 쉽지 않다

코더를 벗어난 프로그래머는 자료구조, 알고리즘, 디자인 패턴에 대해 이해하고 있다. 이는 스스로 코드를 읽어서 작동원리를 이해할 수 있게 해 준다. 또 어떤 함수의 입력과 출력이 정의된 명세서가 주어지면 그 명세를 만족하는 코드(실제 컴파일 가능한 코드 또는 의사 코드)를 만들어낼 수 있게 해 준다. 더 나아가면 일상적인 문제에 대해서 스스로 코드를 짤 수 있게 된다.[8] 더 나아가 자신의 프로그램의 문맥에 맞게 튜닝해서 최적화할 수 있다.

오늘날 플랫폼[9] 싸움이 커지면서 각자 자신들의 플랫폼 생태계를 성장시키기 위해 어플리케이션 만드는 과정을 점점 쉽게 만들어가는 추세이다보니, 과거에는 자신이 만든 프로그램의 몇몇 파트에 다른 라이브러리의 함수를 가져다 사용하는 수준이었다면 요즘엔 아예 프로그램의 구조와 디자인 및 대부분의 뼈대가 되는 코드는 플랫폼에서 제공하는 프레임워크로 만들고 부분부분 자신의 코드를 끼워 넣어 손만 보는 수준까지 왔다.[10] 도구 사용이 쉬워졌다는 것은 도구 자체에 써야 하는 시간과 노력을 원래 목적에 할애할 수 있다는 것이기 때문에, 오히려 환영하는 프로그래머들이 많다. 일일이 다 개발하는 데 드는 시간이 절약되며, 시간은 곧 돈과 연결되기 때문이다.[11]

같은 말로 북미에서는 '코드 몽키'가 있다.

다만, 이 문제는 일자리 구조가 어떻게 형성되었냐에 따른 문제이기 때문에, 특별히 무능한 사람이 고급 프로그래머나 매니저 자리에 앉아서 월급만 떼먹는 경우가 아니라면 누구를 코더라고 비난하지는 말자. 게다가 누가 일을 잘 하는지 못 하는지는 해봐야만 아는 것이다.
4. 조언[편집]
4.1. 첫 언어[편집]
이쪽은 현재 교수자에 따라 의견이 많이 갈리고 있다. 예를 들어, 동일한 학교 학과 과목의 여러 교수 중에도 Python이나 MATLAB 같은 쉬운 것부터 시작하는 교수가 있으며 C, C++, Java 등 실용성이 더 높고 취업이 잘 되는 것부터 시작하는 교수가 있다.

중소기업은 당장 실전에 투입할 인력을 뽑기 때문에 신입이라도 첫 언어가 중요할 수 있지만, 괜찮은 중견 / 대기업은 학벌이나 스펙, 코딩시험 등으로 뽑은 뒤 실무에서 사용할 주력 언어를 다시 교육한다(당신이 사용할 주력 언어는 취업한 회사의 팀장이 정한다). 따라서 첫 직장이 어디냐가 중요하다.

어쨌든 첫 언어를 선택했다면, 다음을 따라가야 한다.

비전공~고졸 출신은 자료구조와 알고리즘, 이산수학을 잘 아는 경우가 적다. 중요성을 알게 되는 건 대개 취직 후 수 년이 지난 후인데, 그 때는 직장을 그만두지 않고서는 시간이 나지 않아 이를 익히지 못하는 경우가 많다. 이 과목들은 프로그래밍의 정수이기 때문에 공부하지 못하면 평생 양산형 개발자(코더)로 남을 수밖에 없다. 이 과정이 탄탄하지 않으면 프로그래밍 어느 영역을 가도 다시 공부해야 하거나 자괴감에 빠질 수 있다. 이 과목을 학부 2학년 수준까지는 익혀야 한다. 알고리즘은 기본적인 정렬 알고리즘이나 탐색 알고리즘, 다익스트라 알고리즘 등이 있다. 사실 위의 과목들을 마스터하게 된다면 교수급이 되어 프로그래머의 최정점에 서게 되는 셈이므로, 마스터할 때까지 공부하려고 할 필요는 없다. 어렵거나 힘들다고 좌절하지 말고, 전부 이해하지는 못하더라도 최소한 필요할 때에는 활용할 수 있도록 준비하는 것이 중요하다.

공부를 할 때든 취직해서 일할 때든 구글링을 생활화하는 것이 좋다. 에러메시지를 긁어다 구글 검색창에 붙여넣기만 해도 스택 오버플로우 사이트에 해법이 올라온 걸 검색할 수 있다.[12] 소스 코드를 읽고 기술자들 사이의 질의응답을 이해할 수 있어야 한다. 토익 점수나 영어 학원 같은 생활영어가 필요한 것은 아니다. 구글 번역과 영어사전만 있으면 된다. 영어 문법을 전혀 몰라도 명사와 동사만 사전 찾아서 뜻을 찾다 보면 비록 시간은 오래 걸리지만 코드의 모든 문장을 완전히 이해할 수 있다. 기초 알고리즘을 표현한 함수의 경우에는 애초에 변수 이름이 알파벳 한 글자로 이루어진 게 많아서 사전조차 찾아볼 필요가 없고 사칙연산만 할 줄 알면 전체 코드를 이해할 수 있다. 인터넷에서 답을 못 찾겠으면 직접 질문해야 하는데 그러려면 생활영어 정도는 구사할 줄 알아야 한다. 그러나 그 정도까지 가지는 않는데 왜냐면 정말 웬만한 문제의 해결법은 구글링만 하면 다 나오기 때문이다.

디자인 패턴은 본인의 실력이 어느 정도 된다고 생각될 때 공부하도록 하자. 디자인 패턴을 알면 당연히 좋지만 그건 어디까지나 패턴을 봤을 때 왜 이 구조가 효율적인지 이해할 수 있는 실력이 되었을 때의 일이다. 어설픈 실력으로 디자인 패턴을 배워봤자 실무에 적용하기는커녕 스파게티 코드가 안 되면 다행이다. 사람에 따라선 디자인 패턴을 불필요한 공부로 보기도 하는데 디자인 패턴이라는 것 자체가 프로그래머들이 많이 쓰는 구조를 패턴화 시킨 것으로 어느 정도 실력이 쌓이면 효율성 때문에 자연스럽게 따라가게 되는 데에다가, 초반부터 패턴을 공부하면 패턴에만 얽매여 유연성을 잃을 수도 있기 때문이다.

어느 정도 준비가 되었으면 GitHub, 스택 오버플로우 등 전 세계 프로그래머들이 모이는 메이저 사이트들을 성지순례하자. 개발자들을 위한 웹사이트 목록을 참고하면 된다. 그리고 GitHub에 올라와 있는 여러 오픈 소스 프로그램들을 내려받아 분석하고, 가능하다면 직접 기여도 해 보자. 수많은 사람들에 의해 쓰이고 있는 공개 소프트웨어의 코드를 뜯어보는 것만큼 좋은 실전 공부가 없다.
4.1.1. 국내 취업에 필요한 C, C++, Java부터 시작해야 가장 유용하다는 쪽[편집]
한국에서 취직하고자 한다면 한국의 현실을 알고 있는 것이 좋다. 한국의 전공자는 C/C++, 비전공자는 Java로 시작하는 경우가 많다. 전자는 대부분의 전공 교수들이 프로그래밍의 기본이라고 생각해 무조건 가르치고 있기 때문이고, Java는 점유율이 높은 덕에[13] 실무 투입에 유용해 전문학교 단골 언어[14]이기 때문이다. 게임 개발이라면 C/C++, 웹 어플리케이션 개발이라면 Java인 건 상식이기에 공부를 시작할 때 원하는 분야에 맞춰 선택하면 된다.

파이썬을 많이 쓰는 곳에 취직하고 싶으면 파이썬을 공부하는 식으로 언어를 선택해도 상관은 없다. 단, 취직이 될 경우에 한해서이다. 파이썬이 많이 쓰이기도 하고 Java에 비해서 쉽다고는 하지만 대한민국의 현실상 파이썬의 비중이 높은 회사가 아니고서야 취직하기가 어렵다. 당장 공공기관만 하더라도 Java를 쓰고 있고 해당 공공기관의 피고용인 입장인 회사들(을), 그 하청업체 회사들(병)이 많기 때문에 Java 일자리가 훨씬 많다. 그리고 SI에 대해서 들어본 적이 있다면 알고 있을 SI의 피라미드 구조를 생각해보면, 대한민국에서 Java나 C/C++는 배우지 않은 상태에서 다른 언어만 배웠을 때 취직할 가능성이 얼마나 낮은지 알 수 있을 것이다. 이러한 현실에서도 파이썬을 배워서 취직하고 싶으면 해외로 눈을 돌리는 것이 좋다.

그렇다고 해서 C/C++이나 Java를 배웠으니 무조건 취직을 할 수 있을 것이라고 생각하는 것은 금물이다. 잡코리아나 사람인에서 Java라고 검색만 해보면 알 수 있는 사실이 있는데 구인광고에서 Java 하나만을 요구하는 회사는 거의 없다. Node.js, AngularJS, jQuery, JSTL, .NET Framework|닷넷 등등 다른 언어를 추가로 요구하는 회사는 심심하면 나타나는 수준이고, 심하면 Java는 자격요건에 나와있지도 않는 경우가 있다. Java는 기본이고 Node.js, JQuery 등을 알고 있는지 모르는지로 취직이 되냐 안 되냐가 결정되는 것이다. 개발하는 데 있어 당연히 Java 하나만을 사용하지는 않고 비슷한 여러 언어를 같이 쓰기 때문이다.[15] 자격요건으로 적힌 언어는 그 회사에서 주로 사용하는 언어를 적어놓기 때문에 해당 언어의 기본 문법 정도는 알면 취업에 도움이 될 것이다. 권장 요건에 불과하기 때문에 적힌 내용 중 조금만 안다고 해도 뽑힐 수 있다. 단, 취직에 성공해서 실무를 시작하게 되면 배우게 될 테니 기본적인 지식은 알고 가는 것이 여러모로 낫다.

Java는 객체지향 언어이기 때문에 소스를 보면 직관적으로 눈에 들어온다. 메서드[16]를 보면 이 메서드가 무슨 역할을 하는지 이 변수가 어디에서 사용되는지 등이 한눈에 들어오기 때문에 이해하기가 쉽다. 그리고 Java는 너무나도 유명하기 때문에 가능한한 쉽게 설명해주는 강의들도 많으니 인터넷에서 검색하면 쉽게 배울 수 있다. 또한 객체가 무엇인지만 알면 Java로 코딩하는데에 어려움은 적다.

한편 Java는 다른 언어에 비해 코드량이 더 많다. 이에 대해 아래쪽 문단에서 주장하는 것처럼 Java에 대해서 이상할 정도로 부정적으로 생각하기도 하고, Java가 다른 언어에 비해 코드량이 더 많은 것을 단점으로 치부하기도 한다. 확실히 Java는 다른 언어에 비하면 쳐야하는 코드가 더 많지만 그것을 개발자가 일일이 치지는 않는다. IDE의 자동완성을 쓰면 쉽게 해결될 문제라서 실무에서는 아무 문제가 안 된다.

개발 속도 외에도 정확성 문제 때문에 자동완성이 우월하다. 사람이 치면 정말 타자 실력이 뛰어나지 않고서야 오타가 발생하게 되어 있다. 하지만 자동완성을 사용하면 이름을 지어줘야 할 때 빼고는 오타가 생길 일이 거의 없다. 논리적 에러보다는 오타로 인해서 에러가 생기는 경우가 일상다반사이다. 출력 메서드 이름이 제일 길다고 하는데 IntelliJ IDEA의 경우 sout이라고만 치면 System.out.println();이 자동으로 완성된다. 이클립스의 경우 syso를 치고 ctrl+space를 누르면 된다. 그리고 이러한 자동완성 기능은 메소드의 호출이나 객체 생성 등 내가 지금 작성하는 코드가 올바른지 실시간으로 확인해주는 역할이라고도 할 수 있다. 올바르지 못한 코드를 작성하면 자동완성 기능이 동작하지 않을 것이기 때문이다. 아래 문단을 보면 초보자에게 IDE를 주는 걸 부정적으로 말하고 있는데 대부분의 유명 IDE는 직관적인 GUI를 지원하므로 단축키나 복잡한 기능 하나하나를 외울 필요 없이 보이는대로 클릭해서 실행시킬 수 있다. 순수하게 텍스트 편집 기능만 제공하는 vim과, 잘못된 코드 구조를 분석하여 컴파일하기 전에 경고를 띄우고 올바른 예시 코드로 리팩토링해주는 IntelliJ IDEA 중 어느 쪽이 초보자 입장에서 쉽고 생산적일지는 굳이 따질 필요가 없을 것이다. 때때로 IDE의 기능에서 벗어나 프로그래머가 직접 튜닝을 해야 하는 복잡한 상황이 생길 수는 있으나, 이것 역시 초보자에게 해당되는 이야기는 아니다.

프로그래밍에 있어 중요한 것 중 하나는 얼마나 코드를 논리적으로 최소화시킬 수 있냐는 것인데 이것을 단순히 코드량이 적을수록 좋다고 생각하는 것은 어리석은 생각이다. 코드량보다는 얼마나 쓸데없는 코드를 제거할 수 있는지가 중요한 것이다. 그리고 쓸데없는 코드를 제거하고도 코드량이 많은 경우는 얼마든지 있다. 왜냐면 실무에서 사용되는 코드는 적게 잡아도 몇백 줄이고 보통은 몇천 줄 이상이다. 그것도 파일 하나 당. 그것을 코드량이 많다고 해서 안 좋은 코드라고 볼 순 없다. 우리가 말을 할 때 명사와 동사의 기본형만 가지고 말을 해도 말은 통한다. 하지만 그 말을 우리가 효율적이라고 생각하는지, 실제로 그렇게만 말하는지 생각해보면 단순히 코드량으로 효율을 따지는 것이 옳기만 한 것인지 답이 나온다. 프로그래밍 '언어'라는 것을 다시 한번 생각해볼 필요가 있다. '좋은 말'이란 너무 짧아서 알아듣기 힘든 말이 아니라 군더더기가 없는 말이며 이것이 뜻을 전달하는 데 있어 가장 좋은 말이라는 것에 동의할 것이다.

물론 Java가 쉽다고는 할 수 없다. Java는 객체 지향 프로그래밍 언어이기 때문이다. 객체지향적으로 프로그래밍하는 방법을 물어보면 대부분의 개발자들이 모른다고 할 것이다. 정말 어려운 개념이기 때문에 전문적 연구자가 아닌 한 객체지향이라는 개념에 대해 실질적, 구체적으로 정의할 수 없다. 사전적 정의는 누구나 말할 수 있지만 어디까지나 사전적 정의일 뿐이다. 이렇게 어려운 개념이라고 해서 너무 걱정하지는 않아도 괜찮다. 객체지향이라는 것을 조금이나마 이해하고 있다면 당신은 전혀 신입 개발자가 아니라는 뜻이니까. 그리고 아래쪽 문단에서 추천하는 Python도 결국 현업에서는 OOP 언어로 활용한다.
4.1.2. 쉬운 언어부터 택한 뒤 이를 기반으로 자기가 필요한 언어로 나아가라는 쪽[편집]
결론부터 말하자면, 취업을 하기 위해서는 활동 분야에 따라 사용할 프로그래밍 언어를 선택해서 공부하면 된다. 이쪽 의견을 따라도 자기 분야에서 사용할 언어를 익혀서 취업하게 된다는 결과는 반대쪽 의견과 똑같다. 자기 분야에서 선호하는 언어로 실전에 사용할 만한 코드를 짤 수 있게 되어야만 취업이 가능하다.

그럼에도 불구하고 이쪽 의견에서는 Python, R(문과 및 통계학), MATLAB(공대), Scratch(초등학생) 등 쉬운 언어부터 시작하고 이런 언어로 자료구조와 알고리즘을 끝내 놓은 뒤에야 자기 분야에서 필요로 하는 언어로 들어가는 것을 추천한다.
쉬운 언어로 시작해서 나중에 어려운 언어를 배우는 것이 처음부터 어려운 언어만으로 배우는 것보다 빠르다고 보기 때문이다. 이 의견은 'Python을 첫 언어로 택해야 필요한 언어를 쉽게 배울 수 있다'는 뜻이다. 반대쪽 의견에서 이 의견에 대해 주장하듯 'Python 외의 언어는 하나도 몰라도 된다'는 식으로 권장하는 것이 아니다.

예를 들어, 가계부 앱을 만들 사람에게 signed int의 최대값이 2,147,483,647이란 걸 외우게 하는 것보다 그냥 BigInt가 자동으로 지원되는 파이썬을 가르치는 게 빠르다. 일단 가계부 앱의 핵심 기능을 다른 방해 요인 없이 학습하고, 나중에 안드로이드 스튜디오로 실제 앱을 개발할 때 자바의 int 타입이 담을 수 있는 숫자에 한계가 있으므로 주의하라고 가르치는 게 낫다.

이해가 빠르거나 인내심이 있다면 그냥 아무 거나 시작해도 잘 한다.[17] 곧바로 자신이 가장 필요로 하는 것부터 시작하면 된다. 하지만 컴퓨터 교육 현실에서는 수많은 낙오자가 발생하고 있으며, 간신히 통과한다 해도 기본을 닦지 못한 코더가 양산될 뿐이다. 그래서 전체적인 프로그래머 인력 풀의 질과 양 둘 다 떨어뜨리는 악영향을 끼치고 있다. 실제로는 첫 언어만 Python으로 바꿔도 쉽게 갈 수 있다. 그나마 Python이 인지도를 많이 넓혀놔서 2019년 현재는 상황이 많이 나아지긴 했다.

C언어를 만든 목적은 유닉스 운영 체제에서 사용하기 위해서이다. 언어 설계자의 기본 가정이 C를 사용할 사람은 이미 컴퓨터 아키텍처의 세부사항을 잘 알고 있다는 것이었다. 그래서 C언어는 프로그래머가 이상한 짓을 해도 최대한 그대로 하려고 들고, 명백하게 망가지기 전까지는 아무런 경고도 하지 않는다. C로 시작하는 데에 한 가지 문제가 더 있는데, 한국 대학 교육 현실상 구세대 표준을 강요하는 곳이 적지 않다.

Java 역시 객체지향 개념이 난해하고 언어가 장황해서 힘들다. 먼저 Boilerplate 문제를 보자. 함수 하나, 연산식 하나를 테스트하려고 해도 public class GuguClass로 시작하는 십여 줄의 코드를 일일이 작성해야 한다. 특히 화면 출력 메소드의 이름이 System.out.println이라는 긴 이름이다.[18] 인기 있는 프로그래밍 언어 중에서 이 정도로 출력 메소드가 긴 언어는 Java가 유일하다. 이게 문제가 되는 이유는 이제 막 코딩에 입문하는 초보자는 코드를 입력하는 과정에서 필연적으로 오타를 치게 되는데 자바는 이 오타 지점을 찾기가 상대적으로 매우 어렵기 때문이다.[19]

거기다 문법이 쉽다-어렵다에 더해 한 가지 차이점이 더 있다. Python은 인터프리터 언어고 C/C++/JAVA는 컴파일 언어다. 초심자는 인터프리터 언어부터 배우는 게 유리하다. 왜냐하면 인터프리터 언어는 코드의 실행 결과를 즉시 확인해볼 수 있고, 컴파일 언어는 컴파일이 끝나야 결과를 확인할 수 있다. 컴파일 언어는 컴파일이 실패하면 코드의 첫 줄도 실행할 수 없다. 컴파일 오류 메시지가 나오긴 하지만, 그 컴파일 오류 메시지를 해독해내는 시점에서 이미 초보가 아니다. 이 때문에 초보자는 잘못된 곳을 찾기 위해 코드의 모든 줄을 검사해야 하고 심지어는 컴파일 명령 자체에 오타가 있는지까지 확인해야 한다. 반면 인터프리터 언어는 에러가 나기 전까지는 코드를 꾸역꾸역 실행하므로 오류가 난 줄 바로 직전까지 코드를 실행할 수 있다.

Python 강의는 도처에 널렸으므로 적당한 강의 하나 골라잡고 따라하다보면 일단 코더 수준은 될 수 있다. 80년대생 프로그래머는 BASIC부터 시작했던 경우가 많은데, 21세기의 Basic이라고 할 만한 것이 바로 Python이다. 문법 자체도 영어로 글쓰듯이 만들어져 있어 접근성이 굉장히 높다. 영미권에서 먼저 배우는 이유가 그만큼 친숙한 영어를 기반으로 되어있기 때문. 사실 미국에서 진짜 입문용으로 가르치는 것은 Scratch라는 언어인데, 이 스크래치는 철저히 교육용이기 때문에 실용적인 프로그램을 만들기는 어렵다. Python은 매우 고성능이기 때문에 과거의 BASIC이나 오늘날의 Scratch와 달리 입문 이후에도 주력으로 사용할 수 있다.
4.2. 필요한 장비[편집]
프로그래밍 공부를 시작한 정도이거나 타 분야에 종사하는 사람이 간단한 프로그래밍을 적용하는 정도라면 그냥 지금 쓰고 있는 컴퓨터를 사용하면 된다. 요구되는 장비의 성능은 종사하는 분야에 따라 다르다.

크로뮴이나 리눅스 같이 대규모 프로젝트를 관리하는 전문 프로그래머라면 생산성 향상을 위해 컴파일 속도가 중요해지므로, CPU 성능이 좋아야 한다.

영상 처리, 3D 그래픽, 시뮬레이션, 머신 러닝 같은 병렬 처리가 필요한 분야의 경우 그래픽카드의 성능이 많이 요구된다. 내장 그래픽을 쓰는 사무용 노트북에다가 이런 것을 돌리면 매우 오래걸리거나 메모리 초과로 뻗어버린다.

2010년대 후반 이후의 요즘에는 노트북 한 대로 퉁치려는 경향이 강하다. 화면 크기를 제외하고 나머지 스펙은 프로그래머가 개발용으로 쓰기에 충분할 정도로 기술이 발전했기 때문이다.

대부분의 상황에서는 인텔 i5 이상이나 AMD의 라이젠 5 이상 정도면 충분하다.
4.2.1. 운영체제[편집]
입문자의 경우, 프로그래밍을 위해 자신이 쓰던 운영체제를 무리하면서까지 바꿀 필요는 없다. IDE 개발사 JetBrains가 자사 제품의 사용자들을 대상으로 진행한 설문조사에 따르면, 2019년 기준으로 개발자들이 가장 많이 사용하는 운영체제는 윈도우였다. # JetBrains의 툴들이 운영체제에 비종속적인 웹 개발에 많이 쓰인다는 점을 생각하면, 세간에 널리 퍼진 "윈도우는 개발용으로는 잘 안 쓰인다"는 말은 틀린 부분이 있다.

일반적으로 널리 쓰이는 윈도우, macOS, 리눅스 환경에는 프로그래밍 입문에 필요한 환경을 쉽게 구축할 수 있다. 다만 서버 프로그래밍 분야는 리눅스 환경이 타 OS보다 압도적으로 개발환경 구축이 쉽다.[20] 그 다음으로는 macOS가 유리한데, HomeBrew라는 CLI 기반 패키지 관리자를 지원하여 리눅스와 거의 동일한 환경을 제공하기 때문이다.

특정 운영체제에 종속적인 프로그램을 개발하려면(예: DirectX 게임 프로그램, iOS 앱 등) 해당 운영체제의 사용이 필수적이겠지만, Java, Python 등의 언어 실행 환경을 비롯하여 멀티 플랫폼을 지원하는 개발 도구도 많이 찾아볼 수 있다.
4.2.2. 모니터[편집]
입문자라면 모니터는 신경 쓸 필요 없다. 공부를 하는 데에는 화면에 코드 편집창을 띄울 수 있고, 관련 문서를 띄울 수 있다면 충분하다. 그래도 모니터는 최소 2개 이상을 쓰는 것을 추천한다. 한 쪽에는 코드 편집창을 다른 한 쪽에는 결과창을 띄워놓고 볼 수 있기 때문에 정말로 편하다. 굳이 하나의 모니터로 코드와 결과창을 볼 필요는 없다. 구글 검색창까지 3개

개발용 모니터는 다음 사항을 추천한다:
크기가 크고 해상도가 큰 것
다중 모니터를 사용

개발에 필요없는 기능은 다음과 같다:
144Hz, 같은 고주사율[21]이나 1ms와 같은 짧은 응답속도는 필요없다.
그래픽 관련 직군이 아닌 한 광색역, HDR 같은 색상 표현력도 필요없다.

보통 프로그래밍 입문자의 모니터는 1920*1080 해상도의 FHD 모니터일 가능성이 큰데, 24인치 정도만 돼도 TN 패널을 사용하는 것에 큰 문제는 없다. 지금 쓰는 모니터가 좁다고 느껴져서 바꾸려고 할 때만 고려하면 된다. 그 외에 화면에 빛샘이 있든 불량화소가 있든 멍이 들었든 그런 건 코딩하는데 하등 상관 없으므로 리퍼비시나 중고 모니터를 구하는 것도 괜찮다.

자기가 주로 노트북을 이용해서 여러 곳을 옮겨다니며 코딩을 하는데 더 많은 모니터가 필요하다면, 13~17인치 사이의 포터블 모니터를 추가로 구매하는 것도 좋다.[22]

듀얼 모니터를 설치하기에는 공간이 부족할 경우, 다수의 PC를 연결하여 분할 화면을 띄워주는 PBP(Picture By Picture) 기능이 지원되는 모니터를 구매하는 것도 좋다. 주로 21:9 와이드 모니터들이 이 기능을 탑재하고 있으며, 아무리 와이드하다고 해도 모니터 두 개를 놓는 것만큼 공간을 많이 차지하지는 않으므로 꽤 효율적인 방법이다. 다만 화면 비율이 깨지는 현상이 있는지는 제품마다 다르므로 사전에 주의가 필요하다.

윈도우10 유저의 경우 가상데스크탑 기능을 통해 모니터 하나로 여러대를 쓰는 효과를 볼 수 있다.
4.2.3. 키보드[편집]
손에 피로를 심하게 주는 것을 피하면 된다. 쫀쫀한 키감이 있는 팬터그래프 키보드를 사용하면 얇은 키 스트로크 + 가위식 스위치의 반발력 덕분에 손가락의 피로가 상당히 줄어든다. vim이나 Emacs를 자주 사용하는 프로그래머의 경우, 해피 해킹 키보드를 구입해서 사용하기도 한다. 또는 멤브레인 키보드라 하더라도 키감이 아주 나쁘지만 않다면 상관없다. 주로 로지텍이 사무용 멤브레인, 팬터그래프 키보드들을 많이 만든다.

너무 오래돼서 키가 뻑뻑하거나 휴대성에 극한으로 치중해서 타건감을 완전히 내다버린 키보드는 손가락 부상을 야기한다. 기자나 작가 정도는 아니라고 해도 프로그래머 직군은 타 직종에 비해 키보드를 쓰는 비율이 높다.

기계식 키보드는 소음이 심해 같이 일하는 주변 동료들에게 피해를 주므로, 기계식을 쓸 거라면 저소음 모델[23]을 사용하는 것이 좋다. 다만 저소음 모델이라 해도 팬터그래프 키보드만큼 조용하지는 않다.
4.3. 한 가지 언어만으로는 부족하다[편집]
첫 번째 언어에서 디자인 패턴을 공부할 수준까지 가면, 틈나는 대로 다른 언어들도 공부하는 것이 좋다. 1~2개의 언어만 붙잡고 다른 언어를 외면한다면 어느 순간 도태될 수도 있다. 현실의 외국어와 달리 프로그래밍 언어는 문법이나 용어들이 비슷하므로 C++ 같이 복잡한 언어가 아니라면 습득하는 데 큰 노력이 들지 않는다. 물론 그 많은 언어들을 다 유창하게 사용할 능력까지는 필요 없고, 간단한 프로그램을 만들 정도만 익혀도 부족하지 않다. 나중에 그 언어를 주력으로 사용하게 될 때, 나머지 상세한 부분을 공부해도 좋다.

누구나 그렇듯이, 트렌드를 지속적으로 따르는 건 어렵다. 라이브러리나 프레임워크를 뺀 순수 '언어'들만 해도 200여 종이 넘는다. 점유율 3% 넘는 것들만 쳐도 5종이다. 그 중에서 다음 프로젝트에 무슨 언어가 쓰일 지는 확정지을 수 없다.[24] 게임 개발의 경우 C++이나 C#이 보통이지만, 갑자기 Python을 같이 사용해야 하는 경우도 있다.[25]

심지어는 갑자기 언어에 변혁이 일어나기도 한다. 1983년부터 Objective-C가 개발되어 맥과 iPhone 앱에서 잘 쓰이고 있었는데, 2014년 애플에서 더효율적인 Swift를 발표했다. Objective-C로 코딩한 결과물이 쓸모없어지는 건 아니지만, Objective-C는 레거시가 되서 지원이 점점 끊긴다.

그러니 그때그때 몸담고 있는 영역에서 유리한 언어를 사용하는 게 편리하다. 아주 오래 전에는 기계어와 어셈블리어밖에 없었으나, 각 언어에는 장단점이 있기 때문에 분야마다 쓰는 언어가 다양해졌다. 이제 한 언어가 모든 분야에 절대적으로 유리하지는 않다. 대개 웹 프로그래머라면 Java와 JavaScript, PHP, 시스템 프로그래머라면 C++, Go를 주력으로 삼는다. 한국 내에서도 이런 수요가 가장 많다. 시장의 수요에 따라 특정 언어를 할 줄 알면 몸값을 올릴[26] 수 있기 때문에 다양한 언어를 다룰 줄 아는 것이 중요하다. 가령 아두이노를 사용한 IoT 디바이스를 웹과 연결하는 프로그램을 짜고 있다고 하자. 웹에서 예를 들면 쇼핑몰을 구축해야 할 때 PHP가 적합한데 C/C++로 CGI로 홈페이지를 구축하는 것은 생산성만 떨어뜨리는 어리석은 접근이다.
Go: C언어가 할 수 있는 일은 죄다 할 수 있으면서도, 컴파일이 빠르고 코딩은 쉽다. 설계자 중 한 명이 C언어를 만든 켄 톰슨이다. 하드리얼타임이 출동하면 어떨까?
Python: C보다 할 수 있는 일들이 적지만, 워낙 쓰기 편한 까닭에 주류 언어의 지위를 차지하고 있다.
Erlang: 원래 통신장비에 들어갈 목적으로 설계된 언어인 탓에 동시접속자가 폭주해도 굳건히 버텨낸다.

프로그래밍 언어/코드 예제 문서에 가보자. "Hello, World!" 외에도 그 아래쪽 것들을 구경해볼 것. 열 줄짜리 구구단 출력 자바 코드가 Ruby 언어에 가면 매우 줄어든다.

Java의 예를 들어보자. 처음엔 날코딩에서 시작해 IDE를 쓰게 되고, 서드파티 라이브러리를 사용하다가 스프링 프레임워크라는 것이 있다는 걸 알게 되고, 프레임워크의 유연성에 감동하다가, 그 프레임워크를 만든 근간 기술인 디자인 패턴에 대해 공부하게 되고… 그렇게 차츰 자기도 모르게 고급 프로그래머가 되어 간다. 그러나 학습량은 결코 적지 않다. 위에서 트렌드를 이해해야 한다고 했는데, Java 쪽의 트렌드를 따라가려면 읽어야 할 자료가 엄청나게 많다.[27] 그래서 다른 것에 한눈팔 여유가 없다. 그래도, Java의 인기와 점유율은 여전히 상당하다.

최신 트렌드를 접하다 보면 스프링 프레임워크를 접할 때 즈음엔 함수형 언어에 대해 알게 된다. 일급 객체, 클로저 등에 대해 10분만 검색하면 인터페이스가 불필요할 수도 있다는 걸 알고 멘붕할 것이다. 객체지향이 진리라고 믿었더라도, 메서드 체이닝과 고차 함수 개념을 접하고 나면 객체를 상속하듯이 행동을 확장할 수 있는 함수형 언어의 설계 패러다임을 접하고 다시 멘붕할 것이다. 그리고 멀티스레드는 금단의 사과 같은 테크닉이라고 믿었더라도 GPGPU를 배우면 스레드가 다다익선일 수도 있음을 알게 된다. 리턴값을 두 개 세 개 막 넘길 수 있는 Python과 Go를 보고, 숫자에 메소드를 붙이고 문자열 자체를 메소드명으로 해석해서 실행시키는 괴랄한 테크닉이 가능한 Ruby를 보고[28], 심지어 같은 자바 가상머신을 사용하는데도 유연성이 훨씬 뛰어난 Scala와 Groovy를 접해보게 된다. 이러한 점 때문에 프로그래밍에 흥미만 붙힌다면 여러가지 다양한 개념과 사고를 접할 수 있기 때문에 정말 프로그래밍 공부가 재미있어진다.[29]

이런 경험을 아예 하지 않으면 더 문제다. 일할 때 속도가 심하게 느려지기 때문이다. 남들이 2주에 400만원이면 충분하다고 하는 프로젝트를 본인 혼자서 2년에 2억을 부른다면 시장에서 도태되고 말 것이다.

이런 과정을 거치다 최정점에 서게 되면 이거고 저거고 다 비슷해 보이는 언어의 한계를 돌파한 polyglot이 된다. 무슨 언어를 쓰든 거기서 거기처럼 느껴질 수도 있겠지만 이 경지까지 가면 스스로 컴파일러를 제작해서 사용할 정도의 초월자가 되어있을 것이라 논외.
4.4. 학위의 위상[편집]
흔히 프로그래머에게는 학력이 중요하지 않다고, 대학 교육이 반드시 요구되는 분야가 아니라고들 한다. 반대로 가능한 한 명문 대학과 명문 대학원을 가야 많은 것을 배울 수 있고 취업도 잘 된다는 말도 있다.

이는 지원자의 능력과 상황에 따라 갈린다.
교수, 정부출연연구소 연구원: 박사학위가 지원자격이다.
경력 없는 신입 개발자로 취업하고 싶지만, 탁월한 능력이 확인되지는 않은 경우
중견기업, 대기업 취업: 국내 대기업은 인서울이나 지방국립대 이상의 학벌과 대졸 이상의 학습기간이 요구된다.
공무원 시험, 공공기관 시험: 블라인드 채용
중소기업, 스타트업 취업: 인기가 없기 때문에 고졸으로도 일자리를 구할 수 있는 경우가 많다. 이런 곳에 다니다가 능력을 배양하여 경력직으로 대기업에 가기도 한다. 또 핵심인재임이 인정될 경우 학력이 낮아도 높은 연봉을 받을 수 있다.
개발자이며 탁월한 능력이 확인된 경우: 학벌이나 재학연한의 중요성이 사라진다. 이들은 고학력이 필요한 내용이라 해도 다 독학해서 배울 능력을 갖추고 있다.
창업을 하려는 경우
국내 벤처캐피탈에서 초기 투자 충분히 받아서 창업하고 싶은 사람: 만약 자신이 카네기멜론 컴공 석사이상 졸업자라면, 국내에서 소프트웨어 벤처 한다고 하면 수억 원 이상은 그냥 투자받을 수 있다.
초기 투자 안 받아도 자기가 직접 앱을 만들어서 팔고 회사 차릴 수 있는 사람: 통계상 학력이 높은 사람이 회사를 차릴수록 수익률이 높고 오래가고 도산율이 낮다. 하지만 자신이 잘 할 수 있기만 하면 학력은 필요없다.

분야에 따라 갈리기도 한다.
직업학교에서도 배우는 정도의 커리큘럼으로 정리가 되어 있고 복잡한 처리를 필요로 하지 않는 분야: 고졸 정도면 시작할 수 있다.
웹 개발자, 모바일 어플리케이션 개발자
SI, SM 쪽 업무: 다만, 시작할 수는 있으나 차별은 좀 있다. "갑"에서는 개발자의 학력이나 학벌을 중요시하기도 한다. 그리고 대학교 졸업장 없이는 실력이 뛰어나더라도 상대적으로 설계 경험을 접해보기 힘든 경향이 있다. 사실 분야 특성상 학력과 실력이 무관한 경우도 많지만, 이런 사실을 잘 모르는 일반인들로서는 편견을 가지기 쉽다. 그리고 이러한 편견을 가진 일반인이 갑의 위치에 있다면.. 하여간 한국에서 사회생활하려면 대학은 나와야 한다
수학, 물리학, 컴퓨터공학 등 대학교 3학년 이상의 고급 지식이 필요한 프로그래밍(빅데이터, 인공신경망 등): 고학력이 반드시 필요하다. 학벌을 보기도 한다.
4.4.1. 고학력이 요구되는 경우[편집]
고급 지식[30]은 실무 경험이나 독학으로 익히기 어려워 이러한 고급 지식을 필요로 하는 고급 엔지니어로 성장하고 싶으면 적어도 인서울이나 지거국 수준의 대학에 진학하는것이 좋다 한국에서 고급 지식을 효율적으로 얻을 수 있는 곳은 좋은 대학이지만 컴퓨터공학/소프트웨어과는 구조적인 문제로 커리큘럼이 낙후되어 있다.

한국의 대학원 또한 마찬가지. 애초에 중요한 건 대학원을 나왔느냐가 아니라 어떤 지도교수 밑에서 어떤 수준의 교육을 받고 어떤 퀄리티의 논문을 냈느냐다. 좋은 지도교수 밑에서 잘 트레이닝 된 석사가 부족한 지도교수 밑에서 열심히 노력한 박사보다 낫다. 세계적인 수준의 교육을 제공하는 대학원은 한국에 두세 곳뿐이고, 이런 대학원은 들어가기가 상당히 어렵다. 단순히 학위 취득을 위해 특수대학원을 다니는 직장인들도 있는데, 당연하지만 일반대학원을 나온 사람들과 동일한 대우는 받지 못한다.

참고로 미국도 마찬가지다. 최상위권 대학은 한국의 탑3 대학보다도 환경이 좋지만, 조금만 순위가 내려가더라도 수업의 질이 크게 떨어지고, 이는 결국 졸업생의 경쟁력 저하로 이어진다.

또한 대기업이나 괜찮은 중견기업에 입사하고자 할 때는 최소한 형식적인 문제 때문에 대학 졸업장이 당연히 필요하다.
미국도 프로그래머로 취업하려면 보통 대학을 졸업해야 하고 구글, 오라클 같은 대기업에 취업하려면 명문대 출신이 아무래도 유리하다. 취업과 별개로 비자 문제에도 유리하다.
4.4.2. 학력이 낮을 경우[편집]
본인 영어 실력이 좀 된다면 독학으로 전문 지식을 익힐 방법이 있다. Coursera, edx, MITOCW, Udemy 등에서 제공하는 강좌들에서 이런 고급 수학, 물리학 지식을 제공한다.

영어가 안 된다고 해도 GitHub에 가서 MOOC 관련 다운로더 코드를 Python으로 작성해 놓은 것들이 있는데 다운 받아서 실행하면 강의당 용량이 4GB 정도 하는 패키지로 자막까지 받을 수 있다.
4.5. 다른 분야의 지식[편집]
실무에서 다른 전공지식이 필요한 부분에 대해서는 그 전공지식과 업무에 대한 이해가 필수적이다.
CAD/CAE: 기계공학, 전자공학, 건축학 관련 지식
3D 그래픽 라이브러리(OpenGL 등): 기하광학
게임 물리 엔진(PhysX,Havok): 역학 위주의 게임 물리학
기계학습: 선형대수학(Matlab), 통계학(파이썬의 텐서플로우) 등의 수학
금융권 (보험회사 전산실): 이원분석, 보험수리
금융권 (재무 정보): 고급회계
임베디드 시스템,FPGA: 전자공학
경우에 따라서는 납땜, 용접 등도 해야 할 수 있다.
4.6. 필요한 능력[편집]
attachment/프로그래머...

[31]
여러가지 프로그래밍 언어를 구사할 줄 알아야 하며, 직종에 따라 다양한 툴과 엔진을 다룰 줄 알아야 한다. 한편 직접 툴을 다루진 않지만 데이터베이스, 알고리즘, 자료 구조간의 관계/구조를 설계하는 사람을 소프트웨어 설계자(아키텍트)라고 구분하여 부르기도 하는데, 아키텍트는 당연히 관련 분야 지식을 알아야 한다.
4.6.1. 꾸준한 공부[편집]
그 중에는 프로그래밍 자체에 대한 흥미 및 이 분야의 트렌드를 지속적으로 구독하는 능력 및 꾸준한 공부습관도 포함되어 있다. IT 분야는 발전속도가 매우 빠른 분야이기 때문에 공부를 그만두면 도태될 수밖에 없다. 따라서 그만두는 순간까지 꾸준히 공부해야 한다. 뜬구름 같은 이야기일 수도 있지만, 프로그래머에게 필요한 가장 중요한 적성은 프로그래밍 그 자체에 대한 흥미라고 할 수 있다.

개발도구는 간편해지고 있는데 그런 툴 자체가 워낙 많이 쏟아지고 있어서 프로그래머는 그 수많은 툴 중에 뭘 쓸지 '선택'을 해야 한다. 라이브러리간 호환성이 어떤지, 개발은 계속 되고 있는지, 얼마나 많은 유저가 쓰고 있는지, 그리고 검증되었는지 등을 다 따져봐야 하게 된 것이다. 고민을 하는 동안에도 세계 어딘가에서는 새로운 툴이 만들어져 발표되고 있고 기존 툴이 대대적인 업그레이드를 해서 원래는 후보 탈락이었는데 다시 검토해야 하는 경우도 발생한다. 어떨 때는 1년 동안 고생해서 프로그램을 제작했더니 다른 회사에서 일주일만에 신기술을 도입한 더 좋은 프로그램을 출시해버리는 안습한 상황도 발생한다. 툴 선택이 잘못돼서 생산성이 떨어진 상태로 작업하는 게 어떤 참사를 불러오는지의 가장 극단적인 사례.

IT쪽 뉴스에 뭐가 뜨면 최소한 자기 분야는 죄다 챙겨봐야 한다. 덕분에 학원 출신이라도 이후 독학으로데대학출신을 능가하는 것도 가능하다. 또한 구글링에만 의존할 것이 아니라 잘 쓰여진 책을 가지고 공부하는 것이 중요하다. 인터넷에 떠다니는 정보들은 파편화된 것으로, 전체적인 그림은 알고 있지만 일부 지식을 모를 때 이를 메우기에는 도움이 되나, 처음부터 지식을 쌓아갈 때는 오히려 독이 된다. 최근에는 코딩 교육과 딥 러닝의 열풍으로 컴퓨터 분야 기술 서적의 번역 품질이 상당히 올라간 편이다.

어차피 흥미가 있는 사람이라면 누가 시키지 않아도 직접 찾아서 새로운 기술과 관련 정보를 습득할 테고, 누가 강요하지 않아도 알아서 공부할 것이기 때문에 유리하다. 반면에 시험 같은 강제적인 동기가 없으면 공부를 하지 않는 케이스라면 학교를 졸업하고 난 후 자연스레 공부에 소홀해지고, 그렇게 되면 다른 사람들에 비해 실력이 뒤쳐지는 것이 수순이다.

이렇게 트렌드 파악 및 꾸준한 공부가 필요한 분야이기 때문에 프로그래머 집단은 동종업계 종사자들 사이에서 지식 공유가 활발하게 이루어지는 분야이기도 하다. 예를 들어, 위키위키는 프로그래밍에 쓰는 패턴들을 정리하기 위해서 처음 탄생했다. 또한 모르는 사람들이 모여서 상업적인 목적으로 만든 것보다 쓸만한 물건을 만들어 내는 오픈 소스 프로젝트는 활발한 지식 공유 없이는 유지될 수가 없다.

대부분의 대학교 컴퓨터 공학과 교수들이 코딩을 적게하는 이유가 이 트렌드를 따라가지 않아서이다. 연구분야가 툴 자체인 게 아닌 바에야 교수가 툴에 관심을 가져야 할 이유도 없고. 다른 분야 교수들은 대학원생과 일대일 맞다이를 떠도 꿇릴 게 없는 반면 컴공과 교수들은 프로젝트를 추진하려면 대학원생을 반드시 써야 하는데 이 또한 같은 이유 때문이다. 물론 코딩덕후 출신 교수들도 있긴 한데 전체적인 모양새가 그렇다는 것이다.

컴퓨터 과학이나 계산 과학 분야의 전공 서적이나 논문들은 실제 C 코드 하나 없이 의사 코드나 수식 투성이인 경우가 많다. 학계에서는 C 같은 언어로 실제 구현하는 것은 지나치게 Domain-Specific한 문제라 여기기 때문에, 결국 코딩을 잘 하든 못 하든 논문은 수학 증명 투성이로 써야 한다. 그래서 실제로 컴파일 될 수 있는 코드를 한 줄도 작성하지 못해도 수학적으로 검증된 알고리즘을 만들 수만 있다면 박사 학위를 따거나 교수가 될 수 있다. 그러나 천재가 아닌 한, 직접 수치를 계산해보거나 Plot을 그려보지도 않고 고등 물리학이나 수학 개념들을 이해하기는 어려울 것이다. 그리고 이건 컴퓨터 과학이라는 학문 자체를 연구하는 경우에 해당되는 이야기이며, 대부분의 프로그래머들은 논문을 작성할 일도, 알고리즘 자체를 개발할 일도 없다. 프로그래머가 되겠다고 C 언어 입문서 대신 대학교 수학 교재를 붙들고 있는 건 공부의 방향이 완전히 어긋난 것이다. 새로운 알고리즘을 개발하고 논문으로 발표하는 것은 수학과/암호학과 출신들이 하는 일이고, 프로그래머와 같은 '공학자'들은 그걸 가져다가 코드로 구현하여 애플리케이션을 만드는 일을 맡는다.

해외 코딩 문제은행 사이트에 꾸준히 들러서 문제를 푸는 것도 좋은 방법이다. 기초부터 시작하고 싶다면 HackerRank, 깊이 있는 문제들을 원한다면 LeetCode 또는 InterviewBit를 방문해 보자.
4.6.2. 영어[편집]
코더를 넘어서서 제대로 대접받는 프로그래머가 되고 싶다면 영어로 된 기술언어 정도는 읽고 쓸 수 있게 공부할 것을 추천한다. 컴퓨터는 미국에서 만들었고 미국이 리드하고 있으며, 한국어로 된 프로그래밍 정보보다 영어로 된 정보가 압도적으로 많기 때문이다.

그렇지만 영어를 못 한다고 좌절하지는 말자. 영어에도 분야에 따라 난이도라는 게 있다. 기술자 영어는 생활영어보다도 난이도가 낮은 아주 쉬운(!) 영어다. 어휘 자체가 공학영어는 생활영어보다 적고, 3형식을 넘어가는 문장은 거의 쓰이지 않으며 에둘러 표현하는 것 따위는 절대 없다. 또한 문장에 애매모호함 따위는 없고 거의 모든 문장의 의미가 명확하다. 애초에 공학계열에서 쓰이는 영어로 된 것들 대부분이 명시적인 생각을 중요하게 여기기 때문이다.[32]

일반인이 들었을 때 왈도체스러운 영어를 구사하게 되니까 거기서 만족하면 곤란하지만 어쨌든 같은 기술자끼리는 말이 통한다. 정 안통하면 코드로 대화할 수도 있다. Stack Overflow 사이트라면, 내 코드 쭉 긁어다 붙이고 나서 "I expected True but False." 라고 하든지 "It should be True." 또는 "Not working." 이라고 하면 상대방이 알아서 코드를 읽고 의도를 파악해서 답변을 달아 줄 것이다. 물론 검색해서 답이 나오는 문제를 이런 식으로 질문하면 쫓겨나는 수가 있으므로 그건 주의할 것. if(you == mad) { this = 'Sparta!'; }
4.7. 연봉과 근무[편집]
타 직종도 비슷하겠지만, 연봉(시간당 급여)은 프로그래머의 실력을 나타내는 객관적인 지표가 된다. 인맥 등의 이유로 실력이 없는데 연봉이 높을 수는 있지만 실력이 좋은데 연봉이 낮은 케이스는 거의 없기 때문.[33] 굳이 코더와 프로그래머를 구분해야겠다면 연봉이 구분자가 될 것이다

북미의 경우 스택 오버플로우에서 조사한 2016년 자료에 따르면 평균 $106,120로 연봉이 높은 직업(developer)에 속한다. 다른 나라들도 대부분 높은 편이며 한국도 $45,000로 연봉이 높은 축에는 들지 못해도 국내 사무직 평균보다는 높다. 물론 실력이 없으면 말짱 도루묵이다.

연봉은 보유한 기술에 따라 달라지기도 한다. 북미 기준 가장 높은 보수를 받는 기술로는 스파크와 스칼라가 선정되었으며 그 위로 카산드라, F#, Go, Clojure 등이 차례로 선정되었다. 업종에 따라서 구분해도, 상대적으로 접근이 쉬운 웹 프론트 개발자보다는 아이폰 개발자의 급여가 더 높은 것으로 나온다.[Disclaimer]

프로그래머별 연봉의 편차가 큰 편이다. 취업할 때부터 이 차이는 시작된다. 국내 대졸초임 기준으로 적게는 2200부터 시작하는 중소기업도 있지만 성과급 포함 6000으로 시작하는 대기업도 있다. 아쉽게도 신입인 경우 유명 코딩 대회 입상 경력이 있거나 유명 오픈소스 커미터가 아닌 이상 기업의 연봉테이블에 따라 낮은연봉으로 결정되는 경우가 대부분이다.

경력직의 경우 인사고과에 크게 의존하는 타 직종과는 달리 면접 시 간단한 시험을 보는 등 실력 측정이 상대적으로 용이하기 때문에 연봉을 높이기 위해 잦은 이직[35]을 하는 사람도 많은 편이며, 그만큼 연봉의 편차가 심해진다. 수년 전에 올라온 연봉관련글에 다들 의견이 제각각이다 경력직으로 입사한 동료 개발자의 연봉을 알고 나서 퇴사를 결심했다는 이야기도 종종 들릴 정도.[36] 대기업이나 괜찮은 중견기업은 추천으로도 많이 뽑기 때문에 실력은 기본이고 자신을 좋은 회사에 추천해줄 인맥 관리도 해두는 것이 좋다.

프로그래머의 근무 형태는 일반적인 사무직과 비슷하다. 인하우스로 근무하건 파견을 나가서 온사이트로 근무하건 일단 출근은 사무실로 한다. 다른 직장과 다른 점은 현장에 나가거나 출근을 해야 업무효율이 극대화돠는 게 아니라서 재택 근무나 투잡 형식의 알바가 가능하다는 것이다. 직종 특성상 신기술 도입에 적극적이다 보니 영어만 통하면 몸은 한국인데 재택근무로 해외에서 일하는 것도 가능하다. 회사에 별로 일이 없는데, 뭔가 매일 열심히 만들고 있는 사람이 있다면 회사 몰래 투잡을 하고 있을 가능성이 있다. SI나 소규모 앱 개발 등에서는 아예 정규직 형태가 아니라 프리랜서 형태로 근무하는 경우도 많다. 비전문가가 본다면 일하는 건지 노는 건지 구분하기 힘들다.

단, FA 분야처럼 직접 기계장비를 제어해야 하는 경우 공장으로 출근을 해야 하는 경우도 있다.
5. 기타[편집]
고급 프로그래머도 사람이기 때문에 설계 미스를 내는 경우가 있다. 대표적인 경우가 Win32 애플리케이션 API. 왠지 NULL값을 파라메터에 자주 넘긴다. Win32 API가 NULL값을 파라메터로 많이 받는 이유는 레거시 시스템 호환성을 어거지로 끌어안고 차기버전으로 넘어가고 있기 때문에 설계미스라고 하기엔 조금 억울한 면이 있으나 같은 처지의 POSIX 호환 API에는 이런 게 거의 없다는 점을 고려하지 않을 수 없다. 그리고 PHP라는 언어도 함수 이름에 일관성이 없어서 레퍼런스를 항상 참고해야 한다. 뭔가 프레임워크를 사용하는 방식이 어렵게 느껴지면 첫째는 본인 실력을 의심해야 하는 게 맞지만 둘째로는 그 프레임워크의 설계가 잘못되어 있을 가능성도 고려하자. 안 되던 일이 프레임워크를 바꿨더니 일사천리로 진행되는 경우도 간혹 있다. 대형 프레임워크일수록 이런 설계 결함이 발생할 확률이 높아지기 때문에 몇몇 프로그래머는 '마이크로 프레임워크' 쪽으로 전향하기도 한다.

2016 기준으로 미국 IT 업체 개발자 남성과 여성 비율(100기 준)은 애플이 80:20, 트위터는 90:10, 구글은 83:17, 페이스북은 85:15 수준이다.
프로그래머를 골때리게 하는법:세미클론(;)하나를 그리스어물음표(;)로 바꾸면 된다.
6. 유사 용어[편집]
개발자
코딩덕후
'프로그'래머 - 가끔 농담삼아 하는 자학개그의 일종.
7. 관련 문서[편집]
컴퓨터 관련 정보
[1] 사실 HTML은 일반적인 프로그래밍 언어와는 다른 마크업 언어라는 물건이다.
[2] HTML은 유저기반 프로그래밍 언어로 전세계 모든 HTML은 사용자가 소스 코드를 열어볼 수 있다. HTML 내에 있는 각종 태그와 CSS 등등을 전부 사용자 컴퓨터의 자원(CPU, 메모리 등등)을 이용해 구성해야 하기 때문, 하지만 보여지는 값일 뿐 그 안에는 HTML을 구성해주는 또다른 프로그램, 서버기반 프로그래밍 언어가 존재하고 있다. 생각해보아라, 게시판 하나를 만들자고 각 게시판의 균일한 규칙이 있는 폰트 크기, 색상, 닉네임, 제목, 내용을 전부 HTML에 기록해둘 것인가? 그렇게 하면 유지보수도 어렵고, 소스 구성을 제 3자가 악의적인 목적으로 활용한다면 프로그램을 마음대로 복제하고 가공해서 사용할 수 있게 된다.
[3] 잉여력이 넘치는 디시에서는 프로그램을 짜 도둑맞은 갤럭시탭을 되찾은 사람도 있었다.# 물론 안드로이드 버전이 2.X대였을 시절에나 가능한 이야기로, 게시물 날짜를 보면 딱 그 시기인 것을 알 수 있다. 이후 버전이 올라가면서 스토어에 등록되지 않은 어플은 원격 설치가 불가능하게 패치되었고, 스토어에 등록을 하려고 하더라도 백그라운드에서 IP, SSID, BSSID를 전송하거나 GPS, 카메라를 가동할 수 있는 백도어 기능이 있는 앱은 스토어에 등록할 수 없어 더 이상은 어려운 이야기.
[4] 타 분야와 달리 특정 언어 하나를 딱 집어서 지칭하는 이유는 2019년 현재 장치 드라이버 등의 저수준 제어를 위한 언어로는 C언어가 유일하기 때문이다.
[5] React의 경우 React Native를 통해 모바일 어플리케이션도 작성하고 Electron을 통해 PC에서 돌아가는 응용프로그램도 작성이 가능하므로 언어 하나로 다양한 플랫폼을 지원하는게 가능하다.
[6] 물론 6개월~1년 정도 배운 '코더'의 임금 수준은 낮은 편이며, 그들 상당수는 미래에도 높은 임금을 받지 못한다.
[7] 그냥 복붙하면 당연히 에러난다.
[8] 문제를 해결하는 방법/절차를 '알고리즘'이라 한다. 지구상의 누구도 푼 적 없을 정도로 거창한 문제를 푸는 건 교수급에서 할 일이지만, 일상적이고 소소한 문제를 푸는 건 프로그래머도 할 수 있다. 일상적인 문제를 풀 수 없다면 매일 다른 사람에게 질문해가며 의지해야 한다는 소리다.
[9] 기반 프로그램. 운영체제(OS)나 카카오톡과 같이 여러가지 프로그램들이 작동하는 데 있어 기반이 되는 프로그램을 뜻한다.
[10] 윈도우 프로그래밍의 MFC와 같다.
[11] 그러나 손쉽게 배울 수 있는 만큼 그 영역에 대한 진입장벽이 점점 낮아지기 때문에 프로그래머들에게 꼭 이득이 되는 것만은 아니다. 그만큼 경쟁이 더 심화될 것이기 때문이다.
[12] 아니면 한국인 중 누군가가 직접 겪은 경험담이 적힌 개인 사이트가 검색될 수도 있다. 웬만한 것은 한국어로도 해결법이 적혀 있다.
[13] 대한민국의 대부분, 특히 공공기관 쪽의 프로젝트는 백이면 백 Java를 사용했다고 생각해도 될 정도로 비중이 높다.
[14] 높은 점유율만이 이유인 것은 아니다. 교육생 입장에서는 현장에서 안 쓰는 언어를 교육용으로 배우는 것은 쓸데없어 보이니 수강을 거부한다. 교육기관은 교육생의 요구에도 맞춰줘야 하고, 교육용 언어와 실무용 언어 두 종류를 가르치기보다는 실무용 언어 하나만 가르치는 것이 최단 기간에 진도를 빨리 뺄 수 있으니 실무용 언어부터 가르치려고 한다.
[15] 서로 비슷한 언어의 예를 들면 알골 계열 언어들이 있다. 또 객체지향언어는 같은 패러다임에 속한 언어가 비슷하다.
[16] Java에서는 모든 함수가 클래스에 속해 있으므로 메서드라 칭한다.
[17] 가령, 유명한 해커인 이정훈은 중학교 때 C부터 독학으로 시작했다.
[18] import static java.lang.System.out이라는 코드로 System 접두어는 줄일 수 있다. 그래봐야 out.println이다. 여기서 더는 못 줄인다.
[19] 클래스는 대소문자를 구분함, 클래스의 디렉토리 패스와 패키지 패스는 일치해야 함, 한 파일에는 한 개의 public 클래스만 존재할 수 있음, public으로 선언된 클래스명과 파일명은 일치해야 함 등 제약이 심하다.
[20] 명령어 하나로 라이브러리와 개발 도구를 한꺼번에 설치할 수 있다.
[21] 모니터의 화면 갱신 시간이 짧은 것을 말한다. 반응 속도가 중요한 게임에서 주로 사용된다.
[22] 보통 DisplayLink 기술을 이용한다. 별도의 DisplayLink 드라이버 설치가 필요하다.
[23] 저소음 적축 등.
[24] 물론 전문분야 자체를 바꾸는 게 아니라면 대략 3종 내에서 결정되는 편이다.
[25] 맥시스는 유명 개발사인데 심즈4에서 C++과 파이썬을 혼용했다. 하지만 한국 업계에서는 듀랑고 때문에 왠지 파이썬을 기피하는 분위기가 생겨버렸다.. 사실 서버 문제는 언어와는 관계가 없긴 하다만, 기획자들은 그걸 모른다.
[26] 대기업에서 ERP가 유행할때 ABAP 프로그래머나 아이폰 발매 초기 C 프로그래머 등.
[27] 단순한 양만을 따져봤을 때도 장난이 아닌데 거기에 적용된 개념을 이해하기 위해 읽어야 하는 것까지 합치면 방대하기 그지없다. 오래된 언어일수록 공부량이 방대한 것은 당연하긴 하다.
[28] 예를 들어 10.times do puts "hello" end 라는 코드가 문법적으로 올바르다. 코드의 의미는 'hello를 10번 출력하라.'
[29] 좋은 점들만 계속 얘기해서 함정에 빠질까봐 얘기하는 것이지만 이는 자기 전문 분야를 확실히 익히면서 추가적으로 공부하라는 거지 주구장창 언어들만 공부해서는 아무것도 안 된다.
[30] 선형대수학, 확률/통계론, 이산수학, 데이터구조, 알고리즘, 컴퓨터 아키텍처, 프로그래밍 언어론, OS, 오토마타, 시스템 프로그래밍, 네트워크, 소프트웨어 공학, 데이터베이스, 컴퓨터그래픽, 전산논리학, 컴파일러, 계산이론, 정보보호, 인공지능, 인간-컴퓨터 상호작용 등
[31] 책상 위와 등 뒤에 달고 있는 것은 레드불. 용도는 야근. 농으로 야근 능력이 필수라 하기도 한다. 비상 걸리거나 마감 직전이라면야 당연히...
[32] 애초에 전공 지식을 이해하는 것이 영어보다 더 어려울 것이다.
[33] 이 업계는 이직과 스카웃이 빈번하다.
[Disclaimer] 링크의 내용은 정확한 통계치가 아니라 설문조사이므로 심각하게 따지지 말고 재미로 보도록 하자.
[35] 보통 개발자의 실력이나 포지션을 이전 직장의 연봉으로 평가(사기업이 일 못 하는 사람한테 돈을 많이 줄 리 없다)하기 때문에 이직 시 연봉은 기존연봉 +@가 되는 경우가 많다.
[36] 이 바닥에서 연봉 공개는 해고사유가 될 수 있으므로 발설에 주의해야 한다.